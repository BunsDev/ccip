// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package burn_mint_whitelisted_token_pool

import (
	"errors"
	"fmt"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
	"github.com/smartcontractkit/chainlink/v2/core/gethwrappers/generated"
)

var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

type RateLimiterConfig struct {
	IsEnabled bool
	Capacity  *big.Int
	Rate      *big.Int
}

type RateLimiterTokenBucket struct {
	Tokens      *big.Int
	LastUpdated uint32
	IsEnabled   bool
	Capacity    *big.Int
	Rate        *big.Int
}

type TokenPoolRampUpdate struct {
	Ramp              common.Address
	Allowed           bool
	RateLimiterConfig RateLimiterConfig
}

var BurnMintWhitelistedTokenPoolMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractIBurnMintWhitelisted\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"allowlist\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"armProxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"capacity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requested\",\"type\":\"uint256\"}],\"name\":\"AggregateValueMaxCapacityExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minWaitInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"}],\"name\":\"AggregateValueRateLimitReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AllowListNotEnabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadARMSignal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BucketOverfilled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ramp\",\"type\":\"address\"}],\"name\":\"NonExistentRamp\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PermissionsError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ramp\",\"type\":\"address\"}],\"name\":\"RampAlreadyExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"SenderNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"capacity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requested\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"TokenMaxCapacityExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minWaitInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"TokenRateLimitReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"AllowListAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"AllowListRemove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"offRamp\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"capacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"indexed\":false,\"internalType\":\"structRateLimiter.Config\",\"name\":\"rateLimiterConfig\",\"type\":\"tuple\"}],\"name\":\"OffRampAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"offRamp\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"capacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"indexed\":false,\"internalType\":\"structRateLimiter.Config\",\"name\":\"rateLimiterConfig\",\"type\":\"tuple\"}],\"name\":\"OffRampConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"offRamp\",\"type\":\"address\"}],\"name\":\"OffRampRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"onRamp\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"capacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"indexed\":false,\"internalType\":\"structRateLimiter.Config\",\"name\":\"rateLimiterConfig\",\"type\":\"tuple\"}],\"name\":\"OnRampAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"onRamp\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"capacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"indexed\":false,\"internalType\":\"structRateLimiter.Config\",\"name\":\"rateLimiterConfig\",\"type\":\"tuple\"}],\"name\":\"OnRampConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"onRamp\",\"type\":\"address\"}],\"name\":\"OnRampRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Released\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"removes\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"adds\",\"type\":\"address[]\"}],\"name\":\"applyAllowListUpdates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"ramp\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"capacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"internalType\":\"structRateLimiter.Config\",\"name\":\"rateLimiterConfig\",\"type\":\"tuple\"}],\"internalType\":\"structTokenPool.RampUpdate[]\",\"name\":\"onRamps\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ramp\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"capacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"internalType\":\"structRateLimiter.Config\",\"name\":\"rateLimiterConfig\",\"type\":\"tuple\"}],\"internalType\":\"structTokenPool.RampUpdate[]\",\"name\":\"offRamps\",\"type\":\"tuple[]\"}],\"name\":\"applyRampUpdates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"offRamp\",\"type\":\"address\"}],\"name\":\"currentOffRampRateLimiterState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"tokens\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"lastUpdated\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"capacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"internalType\":\"structRateLimiter.TokenBucket\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"onRamp\",\"type\":\"address\"}],\"name\":\"currentOnRampRateLimiterState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"tokens\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"lastUpdated\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"capacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"internalType\":\"structRateLimiter.TokenBucket\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllowList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllowListEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getArmProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"armProxy\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOffRamps\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOnRamps\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"contractIERC20\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"offRamp\",\"type\":\"address\"}],\"name\":\"isOffRamp\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"onRamp\",\"type\":\"address\"}],\"name\":\"isOnRamp\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"originalSender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"lockOrBurn\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"releaseOrMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"offRamp\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"capacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"internalType\":\"structRateLimiter.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"setOffRampRateLimiterConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"onRamp\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"capacity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rate\",\"type\":\"uint128\"}],\"internalType\":\"structRateLimiter.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"setOnRampRateLimiterConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x60e06040523480156200001157600080fd5b5060405162002fd038038062002fd083398101604081905262000034916200051d565b82828233806000816200008e5760405162461bcd60e51b815260206004820152601860248201527f43616e6e6f7420736574206f776e657220746f207a65726f000000000000000060448201526064015b60405180910390fd5b600080546001600160a01b0319166001600160a01b0384811691909117909155811615620000c157620000c18162000133565b5050506001600160a01b038316620000ec576040516342bcdf7f60e11b815260040160405180910390fd5b6001600160a01b03808416608052811660a052815115801560c0526200012757604080516000815260208101909152620001279083620001de565b5050505050506200068e565b336001600160a01b038216036200018d5760405162461bcd60e51b815260206004820152601760248201527f43616e6e6f74207472616e7366657220746f2073656c66000000000000000000604482015260640162000085565b600180546001600160a01b0319166001600160a01b0383811691821790925560008054604051929316917fed8889f560326eb138920d842192f0eb3dd22b4f139c87a2c57538e05bae12789190a350565b60c051620001ff576040516335f4a7b360e01b815260040160405180910390fd5b60005b8251811015620002945760008382815181106200022357620002236200061a565b602090810291909101015190506200023d6002826200034f565b1562000280576040516001600160a01b03821681527f800671136ab6cfee9fbe5ed1fb7ca417811aca3cf864800d127b927adedf75669060200160405180910390a15b506200028c8162000646565b905062000202565b5060005b81518110156200034a576000828281518110620002b957620002b96200061a565b6020026020010151905060006001600160a01b0316816001600160a01b031603620002e5575062000337565b620002f26002826200036f565b1562000335576040516001600160a01b03821681527f2640d4d76caf8bf478aabfa982fa4e1c4eb71a37f93cd15e80dbc657911546d89060200160405180910390a15b505b620003428162000646565b905062000298565b505050565b600062000366836001600160a01b03841662000386565b90505b92915050565b600062000366836001600160a01b0384166200048a565b600081815260018301602052604081205480156200047f576000620003ad60018362000662565b8554909150600090620003c39060019062000662565b90508181146200042f576000866000018281548110620003e757620003e76200061a565b90600052602060002001549050808760000184815481106200040d576200040d6200061a565b6000918252602080832090910192909255918252600188019052604090208390555b855486908062000443576200044362000678565b60019003818190600052602060002001600090559055856001016000868152602001908152602001600020600090556001935050505062000369565b600091505062000369565b6000818152600183016020526040812054620004d35750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915562000369565b50600062000369565b6001600160a01b0381168114620004f257600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b80516200051881620004dc565b919050565b6000806000606084860312156200053357600080fd5b83516200054081620004dc565b602085810151919450906001600160401b03808211156200056057600080fd5b818701915087601f8301126200057557600080fd5b8151818111156200058a576200058a620004f5565b8060051b604051601f19603f83011681018181108582111715620005b257620005b2620004f5565b60405291825284820192508381018501918a831115620005d157600080fd5b938501935b82851015620005fa57620005ea856200050b565b84529385019392850192620005d6565b80975050505050505062000611604085016200050b565b90509250925092565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016200065b576200065b62000630565b5060010190565b8181038181111562000369576200036962000630565b634e487b7160e01b600052603160045260246000fd5b60805160a05160c0516128da620006f6600039600081816103c3015281816109940152610dd3015260008181610249015281816107d50152610a1801526000818161020201528181611213015281816112660152818161139501526113e801526128da6000f3fe608060405234801561001057600080fd5b50600436106101775760003560e01c80638627fad6116100d8578063a7cd63b71161008c578063d612b94511610066578063d612b945146103ae578063e0351e13146103c1578063f2fde38b146103e757600080fd5b8063a7cd63b714610380578063b3a3fb4114610388578063c49907b51461039b57600080fd5b80638da5cb5b116100bd5780638da5cb5b146103475780639687544514610365578063a40e69c71461037857600080fd5b80638627fad61461031f578063873813141461033257600080fd5b806354c8a4f31161012f5780637448b3c7116101145780637448b3c7146102955780637787e7ab146102a857806379ba50971461031757600080fd5b806354c8a4f31461026d5780636f32b8721461028257600080fd5b80631d7a74a0116101605780631d7a74a0146101ed57806321df0da7146102005780635246492f1461024757600080fd5b806301ffc9a71461017c578063181f5a77146101a4575b600080fd5b61018f61018a36600461209d565b6103fa565b60405190151581526020015b60405180910390f35b6101e06040518060400160405280601b81526020017f4275726e4d696e74546f6b656e506f6f6c20312e342e302d646576000000000081525081565b60405161019b9190612143565b61018f6101fb36600461217f565b610493565b7f00000000000000000000000000000000000000000000000000000000000000005b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161019b565b7f0000000000000000000000000000000000000000000000000000000000000000610222565b61028061027b3660046121e6565b6104a0565b005b61018f61029036600461217f565b61051b565b6102806102a3366004612329565b610528565b6102bb6102b636600461217f565b6105f8565b60405161019b919081516fffffffffffffffffffffffffffffffff908116825260208084015163ffffffff1690830152604080840151151590830152606080840151821690830152608092830151169181019190915260a00190565b6102806106d6565b61028061032d366004612420565b6107d3565b61033a61093f565b60405161019b91906124af565b60005473ffffffffffffffffffffffffffffffffffffffff16610222565b6101e061037336600461254b565b610950565b61033a610b3f565b61033a610b4b565b6102bb61039636600461217f565b610b57565b6102806103a936600461262e565b610c35565b6102806103bc366004612329565b610c49565b7f000000000000000000000000000000000000000000000000000000000000000061018f565b6102806103f536600461217f565b610d08565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f317fa33400000000000000000000000000000000000000000000000000000000148061048d57507fffffffff0000000000000000000000000000000000000000000000000000000082167f01ffc9a700000000000000000000000000000000000000000000000000000000145b92915050565b600061048d600783610d1c565b6104a8610d4e565b61051584848080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808802828101820190935287825290935087925086918291850190849080828437600092019190915250610dd192505050565b50505050565b600061048d600483610d1c565b610530610d4e565b6105398261051b565b61058c576040517f498f12f600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff831660048201526024015b60405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff821660009081526006602052604090206105bb9082610f9c565b7f578db78e348076074dbff64a94073a83e9a65aa6766b8c75fdc89282b0e30ed682826040516105ec92919061268e565b60405180910390a15050565b6040805160a08101825260008082526020820181905291810182905260608101829052608081019190915273ffffffffffffffffffffffffffffffffffffffff8216600090815260066020908152604091829020825160a08101845281546fffffffffffffffffffffffffffffffff808216835270010000000000000000000000000000000080830463ffffffff16958401959095527401000000000000000000000000000000000000000090910460ff16151594820194909452600190910154808416606083015291909104909116608082015261048d9061114b565b60015473ffffffffffffffffffffffffffffffffffffffff163314610757576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4d7573742062652070726f706f736564206f776e6572000000000000000000006044820152606401610583565b60008054337fffffffffffffffffffffffff00000000000000000000000000000000000000008083168217845560018054909116905560405173ffffffffffffffffffffffffffffffffffffffff90921692909183917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a350565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663397796f76040518163ffffffff1660e01b8152600401602060405180830381865afa15801561083e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061086291906126e6565b15610899576040517fc148371500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6108a233610493565b6108d8576040517f5307f5ab00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6108e1836111fd565b6108eb8484611237565b60405183815273ffffffffffffffffffffffffffffffffffffffff85169033907f9d228d69b5fdb8d273a2336f8fb8612d039631024ea9bf09c424a9503aa078f09060200160405180910390a35050505050565b606061094b6004611372565b905090565b606061095b3361051b565b610991576040517f5307f5ab00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b877f000000000000000000000000000000000000000000000000000000000000000080156109c757506109c5600282610d1c565b155b15610a16576040517fd0d2597600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82166004820152602401610583565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663397796f76040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a81573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610aa591906126e6565b15610adc576040517fc148371500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610ae58661137f565b610aee866113b9565b60405186815233907f696de425f79f4a40bc6d2122ca50507f0efbeabbff86a84871b7196ab8ea8df79060200160405180910390a25050604080516020810190915260008152979650505050505050565b606061094b6007611372565b606061094b6002611372565b6040805160a08101825260008082526020820181905291810182905260608101829052608081019190915273ffffffffffffffffffffffffffffffffffffffff8216600090815260096020908152604091829020825160a08101845281546fffffffffffffffffffffffffffffffff808216835270010000000000000000000000000000000080830463ffffffff16958401959095527401000000000000000000000000000000000000000090910460ff16151594820194909452600190910154808416606083015291909104909116608082015261048d9061114b565b610c3d610d4e565b6105158484848461145c565b610c51610d4e565b610c5a82610493565b610ca8576040517f498f12f600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83166004820152602401610583565b73ffffffffffffffffffffffffffffffffffffffff82166000908152600960205260409020610cd79082610f9c565b7fb3ba339cfbb8ef80d7a29ce5493051cb90e64fcfa85d7124efc1adfa4c68399f82826040516105ec92919061268e565b610d10610d4e565b610d1981611a05565b50565b73ffffffffffffffffffffffffffffffffffffffff8116600090815260018301602052604081205415155b9392505050565b60005473ffffffffffffffffffffffffffffffffffffffff163314610dcf576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4f6e6c792063616c6c61626c65206279206f776e6572000000000000000000006044820152606401610583565b565b7f0000000000000000000000000000000000000000000000000000000000000000610e28576040517f35f4a7b300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60005b8251811015610ec6576000838281518110610e4857610e48612703565b60200260200101519050610e66816002611afa90919063ffffffff16565b15610eb55760405173ffffffffffffffffffffffffffffffffffffffff821681527f800671136ab6cfee9fbe5ed1fb7ca417811aca3cf864800d127b927adedf75669060200160405180910390a15b50610ebf81612761565b9050610e2b565b5060005b8151811015610f97576000828281518110610ee757610ee7612703565b60200260200101519050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610f2b5750610f87565b610f36600282611b1c565b15610f855760405173ffffffffffffffffffffffffffffffffffffffff821681527f2640d4d76caf8bf478aabfa982fa4e1c4eb71a37f93cd15e80dbc657911546d89060200160405180910390a15b505b610f9081612761565b9050610eca565b505050565b8154600090610fc590700100000000000000000000000000000000900463ffffffff1642612799565b90508015611067576001830154835461100d916fffffffffffffffffffffffffffffffff80821692811691859170010000000000000000000000000000000090910416611b3e565b83546fffffffffffffffffffffffffffffffff919091167fffffffffffffffffffffffff0000000000000000000000000000000000000000909116177001000000000000000000000000000000004263ffffffff16021783555b6020820151835461108d916fffffffffffffffffffffffffffffffff9081169116611b66565b83548351151574010000000000000000000000000000000000000000027fffffffffffffffffffffff00ffffffff000000000000000000000000000000009091166fffffffffffffffffffffffffffffffff92831617178455602083015160408085015183167001000000000000000000000000000000000291909216176001850155517f9ea3374b67bf275e6bb9c8ae68f9cae023e1c528b4b27e092f0bb209d3531c199061113e9084906127ac565b60405180910390a1505050565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101919091526111d982606001516fffffffffffffffffffffffffffffffff1683600001516fffffffffffffffffffffffffffffffff16846020015163ffffffff16426111bd9190612799565b85608001516fffffffffffffffffffffffffffffffff16611b3e565b6fffffffffffffffffffffffffffffffff1682525063ffffffff4216602082015290565b336000908152600960205260409020610d1990827f0000000000000000000000000000000000000000000000000000000000000000611b7c565b6040517ff7f4d9da000000000000000000000000000000000000000000000000000000008152600481018290527f00000000000000000000000000000000000000000000000000000000000000009073ffffffffffffffffffffffffffffffffffffffff82169063f7f4d9da90602401600060405180830381600087803b1580156112c157600080fd5b505af11580156112d5573d6000803e3d6000fd5b50506040517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8681166004830152602482018690528416925063a9059cbb91506044016020604051808303816000875af115801561134e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061051591906126e6565b60606000610d4783611eff565b336000908152600660205260409020610d1990827f0000000000000000000000000000000000000000000000000000000000000000611b7c565b6040517fb95aac76000000000000000000000000000000000000000000000000000000008152600481018290527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063b95aac7690602401600060405180830381600087803b15801561144157600080fd5b505af1158015611455573d6000803e3d6000fd5b5050505050565b611464610d4e565b60005b8381101561178157600085858381811061148357611483612703565b905060a0020180360381019061149991906127e8565b90508060200151156116715780516114b390600490611b1c565b15611624576040805160a08101825282820180516020908101516fffffffffffffffffffffffffffffffff908116845263ffffffff4281168386019081528451511515868801908152855185015184166060880190815286518901518516608089019081528a5173ffffffffffffffffffffffffffffffffffffffff1660009081526006909752958990209751885493519251151574010000000000000000000000000000000000000000027fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff939095167001000000000000000000000000000000009081027fffffffffffffffffffffffff0000000000000000000000000000000000000000909516918716919091179390931791909116929092178655905192518216029116176001909201919091558251905191517f0b594bb0555ff7b252e0c789ccc9d8903fec294172064308727d570505cee1ac92611617929161268e565b60405180910390a1611770565b80516040517fd3eb6bc500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9091166004820152602401610583565b805161167f90600490611afa565b1561172357805173ffffffffffffffffffffffffffffffffffffffff1660009081526006602052604080822080547fffffffffffffffffffffff00000000000000000000000000000000000000000016815560010191909155815190517f7fd064821314ad863a0714a3f1229375ace6b6427ed5544b7b2ba1c47b1b5294916116179173ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b80516040517f498f12f600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9091166004820152602401610583565b5061177a81612761565b9050611467565b5060005b818110156114555760008383838181106117a1576117a1612703565b905060a002018036038101906117b791906127e8565b90508060200151156119425780516117d190600790611b1c565b15611624576040805160a08101825282820180516020908101516fffffffffffffffffffffffffffffffff908116845263ffffffff4281168386019081528451511515868801908152855185015184166060880190815286518901518516608089019081528a5173ffffffffffffffffffffffffffffffffffffffff1660009081526009909752958990209751885493519251151574010000000000000000000000000000000000000000027fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff939095167001000000000000000000000000000000009081027fffffffffffffffffffffffff0000000000000000000000000000000000000000909516918716919091179390931791909116929092178655905192518216029116176001909201919091558251905191517f395b7374909d2b54e5796f53c898ebf41d767c86c78ea86519acf2b805852d8892611935929161268e565b60405180910390a16119f4565b805161195090600790611afa565b1561172357805173ffffffffffffffffffffffffffffffffffffffff1660009081526009602052604080822080547fffffffffffffffffffffff00000000000000000000000000000000000000000016815560010191909155815190517fcf91daec21e3510e2f2aea4b09d08c235d5c6844980be709f282ef591dbf420c916119359173ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b506119fe81612761565b9050611785565b3373ffffffffffffffffffffffffffffffffffffffff821603611a84576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f43616e6e6f74207472616e7366657220746f2073656c660000000000000000006044820152606401610583565b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83811691821790925560008054604051929316917fed8889f560326eb138920d842192f0eb3dd22b4f139c87a2c57538e05bae12789190a350565b6000610d478373ffffffffffffffffffffffffffffffffffffffff8416611f5b565b6000610d478373ffffffffffffffffffffffffffffffffffffffff841661204e565b6000611b5d85611b4e8486612839565b611b589087612850565b611b66565b95945050505050565b6000818310611b755781610d47565b5090919050565b825474010000000000000000000000000000000000000000900460ff161580611ba3575081155b15611bad57505050565b825460018401546fffffffffffffffffffffffffffffffff80831692911690600090611bf390700100000000000000000000000000000000900463ffffffff1642612799565b90508015611cb35781831115611c35576040517f9725942a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001860154611c6f9083908590849070010000000000000000000000000000000090046fffffffffffffffffffffffffffffffff16611b3e565b86547fffffffffffffffffffffffff00000000ffffffffffffffffffffffffffffffff167001000000000000000000000000000000004263ffffffff160217875592505b84821015611d6a5773ffffffffffffffffffffffffffffffffffffffff8416611d12576040517ff94ebcd10000000000000000000000000000000000000000000000000000000081526004810183905260248101869052604401610583565b6040517f1a76572a000000000000000000000000000000000000000000000000000000008152600481018390526024810186905273ffffffffffffffffffffffffffffffffffffffff85166044820152606401610583565b84831015611e7d5760018681015470010000000000000000000000000000000090046fffffffffffffffffffffffffffffffff16906000908290611dae9082612799565b611db8878a612799565b611dc29190612850565b611dcc9190612863565b905073ffffffffffffffffffffffffffffffffffffffff8616611e25576040517f15279c080000000000000000000000000000000000000000000000000000000081526004810182905260248101869052604401610583565b6040517fd0c8d23a000000000000000000000000000000000000000000000000000000008152600481018290526024810186905273ffffffffffffffffffffffffffffffffffffffff87166044820152606401610583565b611e878584612799565b86547fffffffffffffffffffffffffffffffff00000000000000000000000000000000166fffffffffffffffffffffffffffffffff82161787556040518681529093507f1871cdf8010e63f2eb8384381a68dfa7416dc571a5517e66e88b2d2d0c0a690a9060200160405180910390a1505050505050565b606081600001805480602002602001604051908101604052809291908181526020018280548015611f4f57602002820191906000526020600020905b815481526020019060010190808311611f3b575b50505050509050919050565b60008181526001830160205260408120548015612044576000611f7f600183612799565b8554909150600090611f9390600190612799565b9050818114611ff8576000866000018281548110611fb357611fb3612703565b9060005260206000200154905080876000018481548110611fd657611fd6612703565b6000918252602080832090910192909255918252600188019052604090208390555b85548690806120095761200961289e565b60019003818190600052602060002001600090559055856001016000868152602001908152602001600020600090556001935050505061048d565b600091505061048d565b60008181526001830160205260408120546120955750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915561048d565b50600061048d565b6000602082840312156120af57600080fd5b81357fffffffff0000000000000000000000000000000000000000000000000000000081168114610d4757600080fd5b6000815180845260005b81811015612105576020818501810151868301820152016120e9565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b602081526000610d4760208301846120df565b803573ffffffffffffffffffffffffffffffffffffffff8116811461217a57600080fd5b919050565b60006020828403121561219157600080fd5b610d4782612156565b60008083601f8401126121ac57600080fd5b50813567ffffffffffffffff8111156121c457600080fd5b6020830191508360208260051b85010111156121df57600080fd5b9250929050565b600080600080604085870312156121fc57600080fd5b843567ffffffffffffffff8082111561221457600080fd5b6122208883890161219a565b9096509450602087013591508082111561223957600080fd5b506122468782880161219a565b95989497509550505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516060810167ffffffffffffffff811182821017156122a4576122a4612252565b60405290565b8015158114610d1957600080fd5b80356fffffffffffffffffffffffffffffffff8116811461217a57600080fd5b6000606082840312156122ea57600080fd5b6122f2612281565b905081356122ff816122aa565b815261230d602083016122b8565b602082015261231e604083016122b8565b604082015292915050565b6000806080838503121561233c57600080fd5b61234583612156565b915061235484602085016122d8565b90509250929050565b600082601f83011261236e57600080fd5b813567ffffffffffffffff8082111561238957612389612252565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019082821181831017156123cf576123cf612252565b816040528381528660208588010111156123e857600080fd5b836020870160208301376000602085830101528094505050505092915050565b803567ffffffffffffffff8116811461217a57600080fd5b600080600080600060a0868803121561243857600080fd5b853567ffffffffffffffff8082111561245057600080fd5b61245c89838a0161235d565b965061246a60208901612156565b95506040880135945061247f60608901612408565b9350608088013591508082111561249557600080fd5b506124a28882890161235d565b9150509295509295909350565b6020808252825182820181905260009190848201906040850190845b818110156124fd57835173ffffffffffffffffffffffffffffffffffffffff16835292840192918401916001016124cb565b50909695505050505050565b60008083601f84011261251b57600080fd5b50813567ffffffffffffffff81111561253357600080fd5b6020830191508360208285010111156121df57600080fd5b600080600080600080600060a0888a03121561256657600080fd5b61256f88612156565b9650602088013567ffffffffffffffff8082111561258c57600080fd5b6125988b838c01612509565b909850965060408a013595508691506125b360608b01612408565b945060808a01359150808211156125c957600080fd5b506125d68a828b01612509565b989b979a50959850939692959293505050565b60008083601f8401126125fb57600080fd5b50813567ffffffffffffffff81111561261357600080fd5b60208301915083602060a0830285010111156121df57600080fd5b6000806000806040858703121561264457600080fd5b843567ffffffffffffffff8082111561265c57600080fd5b612668888389016125e9565b9096509450602087013591508082111561268157600080fd5b50612246878288016125e9565b73ffffffffffffffffffffffffffffffffffffffff8316815260808101610d4760208301848051151582526020808201516fffffffffffffffffffffffffffffffff9081169184019190915260409182015116910152565b6000602082840312156126f857600080fd5b8151610d47816122aa565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361279257612792612732565b5060010190565b8181038181111561048d5761048d612732565b6060810161048d82848051151582526020808201516fffffffffffffffffffffffffffffffff9081169184019190915260409182015116910152565b600060a082840312156127fa57600080fd5b612802612281565b61280b83612156565b8152602083013561281b816122aa565b602082015261282d84604085016122d8565b60408201529392505050565b808202811582820484141761048d5761048d612732565b8082018082111561048d5761048d612732565b600082612899577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fdfea164736f6c6343000813000a",
}

var BurnMintWhitelistedTokenPoolABI = BurnMintWhitelistedTokenPoolMetaData.ABI

var BurnMintWhitelistedTokenPoolBin = BurnMintWhitelistedTokenPoolMetaData.Bin

func DeployBurnMintWhitelistedTokenPool(auth *bind.TransactOpts, backend bind.ContractBackend, token common.Address, allowlist []common.Address, armProxy common.Address) (common.Address, *types.Transaction, *BurnMintWhitelistedTokenPool, error) {
	parsed, err := BurnMintWhitelistedTokenPoolMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BurnMintWhitelistedTokenPoolBin), backend, token, allowlist, armProxy)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BurnMintWhitelistedTokenPool{address: address, abi: *parsed, BurnMintWhitelistedTokenPoolCaller: BurnMintWhitelistedTokenPoolCaller{contract: contract}, BurnMintWhitelistedTokenPoolTransactor: BurnMintWhitelistedTokenPoolTransactor{contract: contract}, BurnMintWhitelistedTokenPoolFilterer: BurnMintWhitelistedTokenPoolFilterer{contract: contract}}, nil
}

type BurnMintWhitelistedTokenPool struct {
	address common.Address
	abi     abi.ABI
	BurnMintWhitelistedTokenPoolCaller
	BurnMintWhitelistedTokenPoolTransactor
	BurnMintWhitelistedTokenPoolFilterer
}

type BurnMintWhitelistedTokenPoolCaller struct {
	contract *bind.BoundContract
}

type BurnMintWhitelistedTokenPoolTransactor struct {
	contract *bind.BoundContract
}

type BurnMintWhitelistedTokenPoolFilterer struct {
	contract *bind.BoundContract
}

type BurnMintWhitelistedTokenPoolSession struct {
	Contract     *BurnMintWhitelistedTokenPool
	CallOpts     bind.CallOpts
	TransactOpts bind.TransactOpts
}

type BurnMintWhitelistedTokenPoolCallerSession struct {
	Contract *BurnMintWhitelistedTokenPoolCaller
	CallOpts bind.CallOpts
}

type BurnMintWhitelistedTokenPoolTransactorSession struct {
	Contract     *BurnMintWhitelistedTokenPoolTransactor
	TransactOpts bind.TransactOpts
}

type BurnMintWhitelistedTokenPoolRaw struct {
	Contract *BurnMintWhitelistedTokenPool
}

type BurnMintWhitelistedTokenPoolCallerRaw struct {
	Contract *BurnMintWhitelistedTokenPoolCaller
}

type BurnMintWhitelistedTokenPoolTransactorRaw struct {
	Contract *BurnMintWhitelistedTokenPoolTransactor
}

func NewBurnMintWhitelistedTokenPool(address common.Address, backend bind.ContractBackend) (*BurnMintWhitelistedTokenPool, error) {
	abi, err := abi.JSON(strings.NewReader(BurnMintWhitelistedTokenPoolABI))
	if err != nil {
		return nil, err
	}
	contract, err := bindBurnMintWhitelistedTokenPool(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPool{address: address, abi: abi, BurnMintWhitelistedTokenPoolCaller: BurnMintWhitelistedTokenPoolCaller{contract: contract}, BurnMintWhitelistedTokenPoolTransactor: BurnMintWhitelistedTokenPoolTransactor{contract: contract}, BurnMintWhitelistedTokenPoolFilterer: BurnMintWhitelistedTokenPoolFilterer{contract: contract}}, nil
}

func NewBurnMintWhitelistedTokenPoolCaller(address common.Address, caller bind.ContractCaller) (*BurnMintWhitelistedTokenPoolCaller, error) {
	contract, err := bindBurnMintWhitelistedTokenPool(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPoolCaller{contract: contract}, nil
}

func NewBurnMintWhitelistedTokenPoolTransactor(address common.Address, transactor bind.ContractTransactor) (*BurnMintWhitelistedTokenPoolTransactor, error) {
	contract, err := bindBurnMintWhitelistedTokenPool(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPoolTransactor{contract: contract}, nil
}

func NewBurnMintWhitelistedTokenPoolFilterer(address common.Address, filterer bind.ContractFilterer) (*BurnMintWhitelistedTokenPoolFilterer, error) {
	contract, err := bindBurnMintWhitelistedTokenPool(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPoolFilterer{contract: contract}, nil
}

func bindBurnMintWhitelistedTokenPool(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BurnMintWhitelistedTokenPoolMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BurnMintWhitelistedTokenPool.Contract.BurnMintWhitelistedTokenPoolCaller.contract.Call(opts, result, method, params...)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.BurnMintWhitelistedTokenPoolTransactor.contract.Transfer(opts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.BurnMintWhitelistedTokenPoolTransactor.contract.Transact(opts, method, params...)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BurnMintWhitelistedTokenPool.Contract.contract.Call(opts, result, method, params...)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.contract.Transfer(opts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.contract.Transact(opts, method, params...)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCaller) CurrentOffRampRateLimiterState(opts *bind.CallOpts, offRamp common.Address) (RateLimiterTokenBucket, error) {
	var out []interface{}
	err := _BurnMintWhitelistedTokenPool.contract.Call(opts, &out, "currentOffRampRateLimiterState", offRamp)

	if err != nil {
		return *new(RateLimiterTokenBucket), err
	}

	out0 := *abi.ConvertType(out[0], new(RateLimiterTokenBucket)).(*RateLimiterTokenBucket)

	return out0, err

}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) CurrentOffRampRateLimiterState(offRamp common.Address) (RateLimiterTokenBucket, error) {
	return _BurnMintWhitelistedTokenPool.Contract.CurrentOffRampRateLimiterState(&_BurnMintWhitelistedTokenPool.CallOpts, offRamp)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCallerSession) CurrentOffRampRateLimiterState(offRamp common.Address) (RateLimiterTokenBucket, error) {
	return _BurnMintWhitelistedTokenPool.Contract.CurrentOffRampRateLimiterState(&_BurnMintWhitelistedTokenPool.CallOpts, offRamp)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCaller) CurrentOnRampRateLimiterState(opts *bind.CallOpts, onRamp common.Address) (RateLimiterTokenBucket, error) {
	var out []interface{}
	err := _BurnMintWhitelistedTokenPool.contract.Call(opts, &out, "currentOnRampRateLimiterState", onRamp)

	if err != nil {
		return *new(RateLimiterTokenBucket), err
	}

	out0 := *abi.ConvertType(out[0], new(RateLimiterTokenBucket)).(*RateLimiterTokenBucket)

	return out0, err

}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) CurrentOnRampRateLimiterState(onRamp common.Address) (RateLimiterTokenBucket, error) {
	return _BurnMintWhitelistedTokenPool.Contract.CurrentOnRampRateLimiterState(&_BurnMintWhitelistedTokenPool.CallOpts, onRamp)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCallerSession) CurrentOnRampRateLimiterState(onRamp common.Address) (RateLimiterTokenBucket, error) {
	return _BurnMintWhitelistedTokenPool.Contract.CurrentOnRampRateLimiterState(&_BurnMintWhitelistedTokenPool.CallOpts, onRamp)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCaller) GetAllowList(opts *bind.CallOpts) ([]common.Address, error) {
	var out []interface{}
	err := _BurnMintWhitelistedTokenPool.contract.Call(opts, &out, "getAllowList")

	if err != nil {
		return *new([]common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new([]common.Address)).(*[]common.Address)

	return out0, err

}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) GetAllowList() ([]common.Address, error) {
	return _BurnMintWhitelistedTokenPool.Contract.GetAllowList(&_BurnMintWhitelistedTokenPool.CallOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCallerSession) GetAllowList() ([]common.Address, error) {
	return _BurnMintWhitelistedTokenPool.Contract.GetAllowList(&_BurnMintWhitelistedTokenPool.CallOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCaller) GetAllowListEnabled(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _BurnMintWhitelistedTokenPool.contract.Call(opts, &out, "getAllowListEnabled")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) GetAllowListEnabled() (bool, error) {
	return _BurnMintWhitelistedTokenPool.Contract.GetAllowListEnabled(&_BurnMintWhitelistedTokenPool.CallOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCallerSession) GetAllowListEnabled() (bool, error) {
	return _BurnMintWhitelistedTokenPool.Contract.GetAllowListEnabled(&_BurnMintWhitelistedTokenPool.CallOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCaller) GetArmProxy(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BurnMintWhitelistedTokenPool.contract.Call(opts, &out, "getArmProxy")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) GetArmProxy() (common.Address, error) {
	return _BurnMintWhitelistedTokenPool.Contract.GetArmProxy(&_BurnMintWhitelistedTokenPool.CallOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCallerSession) GetArmProxy() (common.Address, error) {
	return _BurnMintWhitelistedTokenPool.Contract.GetArmProxy(&_BurnMintWhitelistedTokenPool.CallOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCaller) GetOffRamps(opts *bind.CallOpts) ([]common.Address, error) {
	var out []interface{}
	err := _BurnMintWhitelistedTokenPool.contract.Call(opts, &out, "getOffRamps")

	if err != nil {
		return *new([]common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new([]common.Address)).(*[]common.Address)

	return out0, err

}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) GetOffRamps() ([]common.Address, error) {
	return _BurnMintWhitelistedTokenPool.Contract.GetOffRamps(&_BurnMintWhitelistedTokenPool.CallOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCallerSession) GetOffRamps() ([]common.Address, error) {
	return _BurnMintWhitelistedTokenPool.Contract.GetOffRamps(&_BurnMintWhitelistedTokenPool.CallOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCaller) GetOnRamps(opts *bind.CallOpts) ([]common.Address, error) {
	var out []interface{}
	err := _BurnMintWhitelistedTokenPool.contract.Call(opts, &out, "getOnRamps")

	if err != nil {
		return *new([]common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new([]common.Address)).(*[]common.Address)

	return out0, err

}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) GetOnRamps() ([]common.Address, error) {
	return _BurnMintWhitelistedTokenPool.Contract.GetOnRamps(&_BurnMintWhitelistedTokenPool.CallOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCallerSession) GetOnRamps() ([]common.Address, error) {
	return _BurnMintWhitelistedTokenPool.Contract.GetOnRamps(&_BurnMintWhitelistedTokenPool.CallOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCaller) GetToken(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BurnMintWhitelistedTokenPool.contract.Call(opts, &out, "getToken")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) GetToken() (common.Address, error) {
	return _BurnMintWhitelistedTokenPool.Contract.GetToken(&_BurnMintWhitelistedTokenPool.CallOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCallerSession) GetToken() (common.Address, error) {
	return _BurnMintWhitelistedTokenPool.Contract.GetToken(&_BurnMintWhitelistedTokenPool.CallOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCaller) IsOffRamp(opts *bind.CallOpts, offRamp common.Address) (bool, error) {
	var out []interface{}
	err := _BurnMintWhitelistedTokenPool.contract.Call(opts, &out, "isOffRamp", offRamp)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) IsOffRamp(offRamp common.Address) (bool, error) {
	return _BurnMintWhitelistedTokenPool.Contract.IsOffRamp(&_BurnMintWhitelistedTokenPool.CallOpts, offRamp)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCallerSession) IsOffRamp(offRamp common.Address) (bool, error) {
	return _BurnMintWhitelistedTokenPool.Contract.IsOffRamp(&_BurnMintWhitelistedTokenPool.CallOpts, offRamp)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCaller) IsOnRamp(opts *bind.CallOpts, onRamp common.Address) (bool, error) {
	var out []interface{}
	err := _BurnMintWhitelistedTokenPool.contract.Call(opts, &out, "isOnRamp", onRamp)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) IsOnRamp(onRamp common.Address) (bool, error) {
	return _BurnMintWhitelistedTokenPool.Contract.IsOnRamp(&_BurnMintWhitelistedTokenPool.CallOpts, onRamp)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCallerSession) IsOnRamp(onRamp common.Address) (bool, error) {
	return _BurnMintWhitelistedTokenPool.Contract.IsOnRamp(&_BurnMintWhitelistedTokenPool.CallOpts, onRamp)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BurnMintWhitelistedTokenPool.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) Owner() (common.Address, error) {
	return _BurnMintWhitelistedTokenPool.Contract.Owner(&_BurnMintWhitelistedTokenPool.CallOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCallerSession) Owner() (common.Address, error) {
	return _BurnMintWhitelistedTokenPool.Contract.Owner(&_BurnMintWhitelistedTokenPool.CallOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _BurnMintWhitelistedTokenPool.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _BurnMintWhitelistedTokenPool.Contract.SupportsInterface(&_BurnMintWhitelistedTokenPool.CallOpts, interfaceId)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _BurnMintWhitelistedTokenPool.Contract.SupportsInterface(&_BurnMintWhitelistedTokenPool.CallOpts, interfaceId)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCaller) TypeAndVersion(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _BurnMintWhitelistedTokenPool.contract.Call(opts, &out, "typeAndVersion")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) TypeAndVersion() (string, error) {
	return _BurnMintWhitelistedTokenPool.Contract.TypeAndVersion(&_BurnMintWhitelistedTokenPool.CallOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolCallerSession) TypeAndVersion() (string, error) {
	return _BurnMintWhitelistedTokenPool.Contract.TypeAndVersion(&_BurnMintWhitelistedTokenPool.CallOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactor) AcceptOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.contract.Transact(opts, "acceptOwnership")
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) AcceptOwnership() (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.AcceptOwnership(&_BurnMintWhitelistedTokenPool.TransactOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactorSession) AcceptOwnership() (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.AcceptOwnership(&_BurnMintWhitelistedTokenPool.TransactOpts)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactor) ApplyAllowListUpdates(opts *bind.TransactOpts, removes []common.Address, adds []common.Address) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.contract.Transact(opts, "applyAllowListUpdates", removes, adds)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) ApplyAllowListUpdates(removes []common.Address, adds []common.Address) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.ApplyAllowListUpdates(&_BurnMintWhitelistedTokenPool.TransactOpts, removes, adds)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactorSession) ApplyAllowListUpdates(removes []common.Address, adds []common.Address) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.ApplyAllowListUpdates(&_BurnMintWhitelistedTokenPool.TransactOpts, removes, adds)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactor) ApplyRampUpdates(opts *bind.TransactOpts, onRamps []TokenPoolRampUpdate, offRamps []TokenPoolRampUpdate) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.contract.Transact(opts, "applyRampUpdates", onRamps, offRamps)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) ApplyRampUpdates(onRamps []TokenPoolRampUpdate, offRamps []TokenPoolRampUpdate) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.ApplyRampUpdates(&_BurnMintWhitelistedTokenPool.TransactOpts, onRamps, offRamps)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactorSession) ApplyRampUpdates(onRamps []TokenPoolRampUpdate, offRamps []TokenPoolRampUpdate) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.ApplyRampUpdates(&_BurnMintWhitelistedTokenPool.TransactOpts, onRamps, offRamps)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactor) LockOrBurn(opts *bind.TransactOpts, originalSender common.Address, arg1 []byte, amount *big.Int, arg3 uint64, arg4 []byte) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.contract.Transact(opts, "lockOrBurn", originalSender, arg1, amount, arg3, arg4)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) LockOrBurn(originalSender common.Address, arg1 []byte, amount *big.Int, arg3 uint64, arg4 []byte) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.LockOrBurn(&_BurnMintWhitelistedTokenPool.TransactOpts, originalSender, arg1, amount, arg3, arg4)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactorSession) LockOrBurn(originalSender common.Address, arg1 []byte, amount *big.Int, arg3 uint64, arg4 []byte) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.LockOrBurn(&_BurnMintWhitelistedTokenPool.TransactOpts, originalSender, arg1, amount, arg3, arg4)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactor) ReleaseOrMint(opts *bind.TransactOpts, arg0 []byte, receiver common.Address, amount *big.Int, arg3 uint64, arg4 []byte) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.contract.Transact(opts, "releaseOrMint", arg0, receiver, amount, arg3, arg4)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) ReleaseOrMint(arg0 []byte, receiver common.Address, amount *big.Int, arg3 uint64, arg4 []byte) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.ReleaseOrMint(&_BurnMintWhitelistedTokenPool.TransactOpts, arg0, receiver, amount, arg3, arg4)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactorSession) ReleaseOrMint(arg0 []byte, receiver common.Address, amount *big.Int, arg3 uint64, arg4 []byte) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.ReleaseOrMint(&_BurnMintWhitelistedTokenPool.TransactOpts, arg0, receiver, amount, arg3, arg4)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactor) SetOffRampRateLimiterConfig(opts *bind.TransactOpts, offRamp common.Address, config RateLimiterConfig) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.contract.Transact(opts, "setOffRampRateLimiterConfig", offRamp, config)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) SetOffRampRateLimiterConfig(offRamp common.Address, config RateLimiterConfig) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.SetOffRampRateLimiterConfig(&_BurnMintWhitelistedTokenPool.TransactOpts, offRamp, config)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactorSession) SetOffRampRateLimiterConfig(offRamp common.Address, config RateLimiterConfig) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.SetOffRampRateLimiterConfig(&_BurnMintWhitelistedTokenPool.TransactOpts, offRamp, config)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactor) SetOnRampRateLimiterConfig(opts *bind.TransactOpts, onRamp common.Address, config RateLimiterConfig) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.contract.Transact(opts, "setOnRampRateLimiterConfig", onRamp, config)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) SetOnRampRateLimiterConfig(onRamp common.Address, config RateLimiterConfig) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.SetOnRampRateLimiterConfig(&_BurnMintWhitelistedTokenPool.TransactOpts, onRamp, config)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactorSession) SetOnRampRateLimiterConfig(onRamp common.Address, config RateLimiterConfig) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.SetOnRampRateLimiterConfig(&_BurnMintWhitelistedTokenPool.TransactOpts, onRamp, config)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactor) TransferOwnership(opts *bind.TransactOpts, to common.Address) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.contract.Transact(opts, "transferOwnership", to)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolSession) TransferOwnership(to common.Address) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.TransferOwnership(&_BurnMintWhitelistedTokenPool.TransactOpts, to)
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolTransactorSession) TransferOwnership(to common.Address) (*types.Transaction, error) {
	return _BurnMintWhitelistedTokenPool.Contract.TransferOwnership(&_BurnMintWhitelistedTokenPool.TransactOpts, to)
}

type BurnMintWhitelistedTokenPoolAllowListAddIterator struct {
	Event *BurnMintWhitelistedTokenPoolAllowListAdd

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *BurnMintWhitelistedTokenPoolAllowListAddIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BurnMintWhitelistedTokenPoolAllowListAdd)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(BurnMintWhitelistedTokenPoolAllowListAdd)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *BurnMintWhitelistedTokenPoolAllowListAddIterator) Error() error {
	return it.fail
}

func (it *BurnMintWhitelistedTokenPoolAllowListAddIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type BurnMintWhitelistedTokenPoolAllowListAdd struct {
	Sender common.Address
	Raw    types.Log
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) FilterAllowListAdd(opts *bind.FilterOpts) (*BurnMintWhitelistedTokenPoolAllowListAddIterator, error) {

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.FilterLogs(opts, "AllowListAdd")
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPoolAllowListAddIterator{contract: _BurnMintWhitelistedTokenPool.contract, event: "AllowListAdd", logs: logs, sub: sub}, nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) WatchAllowListAdd(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolAllowListAdd) (event.Subscription, error) {

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.WatchLogs(opts, "AllowListAdd")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(BurnMintWhitelistedTokenPoolAllowListAdd)
				if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "AllowListAdd", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) ParseAllowListAdd(log types.Log) (*BurnMintWhitelistedTokenPoolAllowListAdd, error) {
	event := new(BurnMintWhitelistedTokenPoolAllowListAdd)
	if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "AllowListAdd", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type BurnMintWhitelistedTokenPoolAllowListRemoveIterator struct {
	Event *BurnMintWhitelistedTokenPoolAllowListRemove

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *BurnMintWhitelistedTokenPoolAllowListRemoveIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BurnMintWhitelistedTokenPoolAllowListRemove)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(BurnMintWhitelistedTokenPoolAllowListRemove)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *BurnMintWhitelistedTokenPoolAllowListRemoveIterator) Error() error {
	return it.fail
}

func (it *BurnMintWhitelistedTokenPoolAllowListRemoveIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type BurnMintWhitelistedTokenPoolAllowListRemove struct {
	Sender common.Address
	Raw    types.Log
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) FilterAllowListRemove(opts *bind.FilterOpts) (*BurnMintWhitelistedTokenPoolAllowListRemoveIterator, error) {

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.FilterLogs(opts, "AllowListRemove")
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPoolAllowListRemoveIterator{contract: _BurnMintWhitelistedTokenPool.contract, event: "AllowListRemove", logs: logs, sub: sub}, nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) WatchAllowListRemove(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolAllowListRemove) (event.Subscription, error) {

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.WatchLogs(opts, "AllowListRemove")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(BurnMintWhitelistedTokenPoolAllowListRemove)
				if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "AllowListRemove", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) ParseAllowListRemove(log types.Log) (*BurnMintWhitelistedTokenPoolAllowListRemove, error) {
	event := new(BurnMintWhitelistedTokenPoolAllowListRemove)
	if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "AllowListRemove", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type BurnMintWhitelistedTokenPoolBurnedIterator struct {
	Event *BurnMintWhitelistedTokenPoolBurned

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *BurnMintWhitelistedTokenPoolBurnedIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BurnMintWhitelistedTokenPoolBurned)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(BurnMintWhitelistedTokenPoolBurned)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *BurnMintWhitelistedTokenPoolBurnedIterator) Error() error {
	return it.fail
}

func (it *BurnMintWhitelistedTokenPoolBurnedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type BurnMintWhitelistedTokenPoolBurned struct {
	Sender common.Address
	Amount *big.Int
	Raw    types.Log
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) FilterBurned(opts *bind.FilterOpts, sender []common.Address) (*BurnMintWhitelistedTokenPoolBurnedIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.FilterLogs(opts, "Burned", senderRule)
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPoolBurnedIterator{contract: _BurnMintWhitelistedTokenPool.contract, event: "Burned", logs: logs, sub: sub}, nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) WatchBurned(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolBurned, sender []common.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.WatchLogs(opts, "Burned", senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(BurnMintWhitelistedTokenPoolBurned)
				if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "Burned", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) ParseBurned(log types.Log) (*BurnMintWhitelistedTokenPoolBurned, error) {
	event := new(BurnMintWhitelistedTokenPoolBurned)
	if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "Burned", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type BurnMintWhitelistedTokenPoolLockedIterator struct {
	Event *BurnMintWhitelistedTokenPoolLocked

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *BurnMintWhitelistedTokenPoolLockedIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BurnMintWhitelistedTokenPoolLocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(BurnMintWhitelistedTokenPoolLocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *BurnMintWhitelistedTokenPoolLockedIterator) Error() error {
	return it.fail
}

func (it *BurnMintWhitelistedTokenPoolLockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type BurnMintWhitelistedTokenPoolLocked struct {
	Sender common.Address
	Amount *big.Int
	Raw    types.Log
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) FilterLocked(opts *bind.FilterOpts, sender []common.Address) (*BurnMintWhitelistedTokenPoolLockedIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.FilterLogs(opts, "Locked", senderRule)
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPoolLockedIterator{contract: _BurnMintWhitelistedTokenPool.contract, event: "Locked", logs: logs, sub: sub}, nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) WatchLocked(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolLocked, sender []common.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.WatchLogs(opts, "Locked", senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(BurnMintWhitelistedTokenPoolLocked)
				if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "Locked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) ParseLocked(log types.Log) (*BurnMintWhitelistedTokenPoolLocked, error) {
	event := new(BurnMintWhitelistedTokenPoolLocked)
	if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "Locked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type BurnMintWhitelistedTokenPoolMintedIterator struct {
	Event *BurnMintWhitelistedTokenPoolMinted

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *BurnMintWhitelistedTokenPoolMintedIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BurnMintWhitelistedTokenPoolMinted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(BurnMintWhitelistedTokenPoolMinted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *BurnMintWhitelistedTokenPoolMintedIterator) Error() error {
	return it.fail
}

func (it *BurnMintWhitelistedTokenPoolMintedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type BurnMintWhitelistedTokenPoolMinted struct {
	Sender    common.Address
	Recipient common.Address
	Amount    *big.Int
	Raw       types.Log
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) FilterMinted(opts *bind.FilterOpts, sender []common.Address, recipient []common.Address) (*BurnMintWhitelistedTokenPoolMintedIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}
	var recipientRule []interface{}
	for _, recipientItem := range recipient {
		recipientRule = append(recipientRule, recipientItem)
	}

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.FilterLogs(opts, "Minted", senderRule, recipientRule)
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPoolMintedIterator{contract: _BurnMintWhitelistedTokenPool.contract, event: "Minted", logs: logs, sub: sub}, nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) WatchMinted(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolMinted, sender []common.Address, recipient []common.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}
	var recipientRule []interface{}
	for _, recipientItem := range recipient {
		recipientRule = append(recipientRule, recipientItem)
	}

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.WatchLogs(opts, "Minted", senderRule, recipientRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(BurnMintWhitelistedTokenPoolMinted)
				if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "Minted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) ParseMinted(log types.Log) (*BurnMintWhitelistedTokenPoolMinted, error) {
	event := new(BurnMintWhitelistedTokenPoolMinted)
	if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "Minted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type BurnMintWhitelistedTokenPoolOffRampAddedIterator struct {
	Event *BurnMintWhitelistedTokenPoolOffRampAdded

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *BurnMintWhitelistedTokenPoolOffRampAddedIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BurnMintWhitelistedTokenPoolOffRampAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(BurnMintWhitelistedTokenPoolOffRampAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *BurnMintWhitelistedTokenPoolOffRampAddedIterator) Error() error {
	return it.fail
}

func (it *BurnMintWhitelistedTokenPoolOffRampAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type BurnMintWhitelistedTokenPoolOffRampAdded struct {
	OffRamp           common.Address
	RateLimiterConfig RateLimiterConfig
	Raw               types.Log
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) FilterOffRampAdded(opts *bind.FilterOpts) (*BurnMintWhitelistedTokenPoolOffRampAddedIterator, error) {

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.FilterLogs(opts, "OffRampAdded")
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPoolOffRampAddedIterator{contract: _BurnMintWhitelistedTokenPool.contract, event: "OffRampAdded", logs: logs, sub: sub}, nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) WatchOffRampAdded(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolOffRampAdded) (event.Subscription, error) {

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.WatchLogs(opts, "OffRampAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(BurnMintWhitelistedTokenPoolOffRampAdded)
				if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "OffRampAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) ParseOffRampAdded(log types.Log) (*BurnMintWhitelistedTokenPoolOffRampAdded, error) {
	event := new(BurnMintWhitelistedTokenPoolOffRampAdded)
	if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "OffRampAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type BurnMintWhitelistedTokenPoolOffRampConfiguredIterator struct {
	Event *BurnMintWhitelistedTokenPoolOffRampConfigured

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *BurnMintWhitelistedTokenPoolOffRampConfiguredIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BurnMintWhitelistedTokenPoolOffRampConfigured)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(BurnMintWhitelistedTokenPoolOffRampConfigured)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *BurnMintWhitelistedTokenPoolOffRampConfiguredIterator) Error() error {
	return it.fail
}

func (it *BurnMintWhitelistedTokenPoolOffRampConfiguredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type BurnMintWhitelistedTokenPoolOffRampConfigured struct {
	OffRamp           common.Address
	RateLimiterConfig RateLimiterConfig
	Raw               types.Log
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) FilterOffRampConfigured(opts *bind.FilterOpts) (*BurnMintWhitelistedTokenPoolOffRampConfiguredIterator, error) {

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.FilterLogs(opts, "OffRampConfigured")
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPoolOffRampConfiguredIterator{contract: _BurnMintWhitelistedTokenPool.contract, event: "OffRampConfigured", logs: logs, sub: sub}, nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) WatchOffRampConfigured(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolOffRampConfigured) (event.Subscription, error) {

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.WatchLogs(opts, "OffRampConfigured")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(BurnMintWhitelistedTokenPoolOffRampConfigured)
				if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "OffRampConfigured", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) ParseOffRampConfigured(log types.Log) (*BurnMintWhitelistedTokenPoolOffRampConfigured, error) {
	event := new(BurnMintWhitelistedTokenPoolOffRampConfigured)
	if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "OffRampConfigured", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type BurnMintWhitelistedTokenPoolOffRampRemovedIterator struct {
	Event *BurnMintWhitelistedTokenPoolOffRampRemoved

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *BurnMintWhitelistedTokenPoolOffRampRemovedIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BurnMintWhitelistedTokenPoolOffRampRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(BurnMintWhitelistedTokenPoolOffRampRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *BurnMintWhitelistedTokenPoolOffRampRemovedIterator) Error() error {
	return it.fail
}

func (it *BurnMintWhitelistedTokenPoolOffRampRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type BurnMintWhitelistedTokenPoolOffRampRemoved struct {
	OffRamp common.Address
	Raw     types.Log
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) FilterOffRampRemoved(opts *bind.FilterOpts) (*BurnMintWhitelistedTokenPoolOffRampRemovedIterator, error) {

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.FilterLogs(opts, "OffRampRemoved")
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPoolOffRampRemovedIterator{contract: _BurnMintWhitelistedTokenPool.contract, event: "OffRampRemoved", logs: logs, sub: sub}, nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) WatchOffRampRemoved(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolOffRampRemoved) (event.Subscription, error) {

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.WatchLogs(opts, "OffRampRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(BurnMintWhitelistedTokenPoolOffRampRemoved)
				if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "OffRampRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) ParseOffRampRemoved(log types.Log) (*BurnMintWhitelistedTokenPoolOffRampRemoved, error) {
	event := new(BurnMintWhitelistedTokenPoolOffRampRemoved)
	if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "OffRampRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type BurnMintWhitelistedTokenPoolOnRampAddedIterator struct {
	Event *BurnMintWhitelistedTokenPoolOnRampAdded

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *BurnMintWhitelistedTokenPoolOnRampAddedIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BurnMintWhitelistedTokenPoolOnRampAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(BurnMintWhitelistedTokenPoolOnRampAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *BurnMintWhitelistedTokenPoolOnRampAddedIterator) Error() error {
	return it.fail
}

func (it *BurnMintWhitelistedTokenPoolOnRampAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type BurnMintWhitelistedTokenPoolOnRampAdded struct {
	OnRamp            common.Address
	RateLimiterConfig RateLimiterConfig
	Raw               types.Log
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) FilterOnRampAdded(opts *bind.FilterOpts) (*BurnMintWhitelistedTokenPoolOnRampAddedIterator, error) {

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.FilterLogs(opts, "OnRampAdded")
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPoolOnRampAddedIterator{contract: _BurnMintWhitelistedTokenPool.contract, event: "OnRampAdded", logs: logs, sub: sub}, nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) WatchOnRampAdded(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolOnRampAdded) (event.Subscription, error) {

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.WatchLogs(opts, "OnRampAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(BurnMintWhitelistedTokenPoolOnRampAdded)
				if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "OnRampAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) ParseOnRampAdded(log types.Log) (*BurnMintWhitelistedTokenPoolOnRampAdded, error) {
	event := new(BurnMintWhitelistedTokenPoolOnRampAdded)
	if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "OnRampAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type BurnMintWhitelistedTokenPoolOnRampConfiguredIterator struct {
	Event *BurnMintWhitelistedTokenPoolOnRampConfigured

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *BurnMintWhitelistedTokenPoolOnRampConfiguredIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BurnMintWhitelistedTokenPoolOnRampConfigured)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(BurnMintWhitelistedTokenPoolOnRampConfigured)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *BurnMintWhitelistedTokenPoolOnRampConfiguredIterator) Error() error {
	return it.fail
}

func (it *BurnMintWhitelistedTokenPoolOnRampConfiguredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type BurnMintWhitelistedTokenPoolOnRampConfigured struct {
	OnRamp            common.Address
	RateLimiterConfig RateLimiterConfig
	Raw               types.Log
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) FilterOnRampConfigured(opts *bind.FilterOpts) (*BurnMintWhitelistedTokenPoolOnRampConfiguredIterator, error) {

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.FilterLogs(opts, "OnRampConfigured")
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPoolOnRampConfiguredIterator{contract: _BurnMintWhitelistedTokenPool.contract, event: "OnRampConfigured", logs: logs, sub: sub}, nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) WatchOnRampConfigured(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolOnRampConfigured) (event.Subscription, error) {

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.WatchLogs(opts, "OnRampConfigured")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(BurnMintWhitelistedTokenPoolOnRampConfigured)
				if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "OnRampConfigured", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) ParseOnRampConfigured(log types.Log) (*BurnMintWhitelistedTokenPoolOnRampConfigured, error) {
	event := new(BurnMintWhitelistedTokenPoolOnRampConfigured)
	if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "OnRampConfigured", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type BurnMintWhitelistedTokenPoolOnRampRemovedIterator struct {
	Event *BurnMintWhitelistedTokenPoolOnRampRemoved

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *BurnMintWhitelistedTokenPoolOnRampRemovedIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BurnMintWhitelistedTokenPoolOnRampRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(BurnMintWhitelistedTokenPoolOnRampRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *BurnMintWhitelistedTokenPoolOnRampRemovedIterator) Error() error {
	return it.fail
}

func (it *BurnMintWhitelistedTokenPoolOnRampRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type BurnMintWhitelistedTokenPoolOnRampRemoved struct {
	OnRamp common.Address
	Raw    types.Log
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) FilterOnRampRemoved(opts *bind.FilterOpts) (*BurnMintWhitelistedTokenPoolOnRampRemovedIterator, error) {

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.FilterLogs(opts, "OnRampRemoved")
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPoolOnRampRemovedIterator{contract: _BurnMintWhitelistedTokenPool.contract, event: "OnRampRemoved", logs: logs, sub: sub}, nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) WatchOnRampRemoved(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolOnRampRemoved) (event.Subscription, error) {

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.WatchLogs(opts, "OnRampRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(BurnMintWhitelistedTokenPoolOnRampRemoved)
				if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "OnRampRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) ParseOnRampRemoved(log types.Log) (*BurnMintWhitelistedTokenPoolOnRampRemoved, error) {
	event := new(BurnMintWhitelistedTokenPoolOnRampRemoved)
	if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "OnRampRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type BurnMintWhitelistedTokenPoolOwnershipTransferRequestedIterator struct {
	Event *BurnMintWhitelistedTokenPoolOwnershipTransferRequested

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *BurnMintWhitelistedTokenPoolOwnershipTransferRequestedIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BurnMintWhitelistedTokenPoolOwnershipTransferRequested)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(BurnMintWhitelistedTokenPoolOwnershipTransferRequested)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *BurnMintWhitelistedTokenPoolOwnershipTransferRequestedIterator) Error() error {
	return it.fail
}

func (it *BurnMintWhitelistedTokenPoolOwnershipTransferRequestedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type BurnMintWhitelistedTokenPoolOwnershipTransferRequested struct {
	From common.Address
	To   common.Address
	Raw  types.Log
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) FilterOwnershipTransferRequested(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*BurnMintWhitelistedTokenPoolOwnershipTransferRequestedIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.FilterLogs(opts, "OwnershipTransferRequested", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPoolOwnershipTransferRequestedIterator{contract: _BurnMintWhitelistedTokenPool.contract, event: "OwnershipTransferRequested", logs: logs, sub: sub}, nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) WatchOwnershipTransferRequested(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolOwnershipTransferRequested, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.WatchLogs(opts, "OwnershipTransferRequested", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(BurnMintWhitelistedTokenPoolOwnershipTransferRequested)
				if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "OwnershipTransferRequested", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) ParseOwnershipTransferRequested(log types.Log) (*BurnMintWhitelistedTokenPoolOwnershipTransferRequested, error) {
	event := new(BurnMintWhitelistedTokenPoolOwnershipTransferRequested)
	if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "OwnershipTransferRequested", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type BurnMintWhitelistedTokenPoolOwnershipTransferredIterator struct {
	Event *BurnMintWhitelistedTokenPoolOwnershipTransferred

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *BurnMintWhitelistedTokenPoolOwnershipTransferredIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BurnMintWhitelistedTokenPoolOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(BurnMintWhitelistedTokenPoolOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *BurnMintWhitelistedTokenPoolOwnershipTransferredIterator) Error() error {
	return it.fail
}

func (it *BurnMintWhitelistedTokenPoolOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type BurnMintWhitelistedTokenPoolOwnershipTransferred struct {
	From common.Address
	To   common.Address
	Raw  types.Log
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*BurnMintWhitelistedTokenPoolOwnershipTransferredIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.FilterLogs(opts, "OwnershipTransferred", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPoolOwnershipTransferredIterator{contract: _BurnMintWhitelistedTokenPool.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolOwnershipTransferred, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.WatchLogs(opts, "OwnershipTransferred", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(BurnMintWhitelistedTokenPoolOwnershipTransferred)
				if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) ParseOwnershipTransferred(log types.Log) (*BurnMintWhitelistedTokenPoolOwnershipTransferred, error) {
	event := new(BurnMintWhitelistedTokenPoolOwnershipTransferred)
	if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type BurnMintWhitelistedTokenPoolReleasedIterator struct {
	Event *BurnMintWhitelistedTokenPoolReleased

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *BurnMintWhitelistedTokenPoolReleasedIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BurnMintWhitelistedTokenPoolReleased)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(BurnMintWhitelistedTokenPoolReleased)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *BurnMintWhitelistedTokenPoolReleasedIterator) Error() error {
	return it.fail
}

func (it *BurnMintWhitelistedTokenPoolReleasedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type BurnMintWhitelistedTokenPoolReleased struct {
	Sender    common.Address
	Recipient common.Address
	Amount    *big.Int
	Raw       types.Log
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) FilterReleased(opts *bind.FilterOpts, sender []common.Address, recipient []common.Address) (*BurnMintWhitelistedTokenPoolReleasedIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}
	var recipientRule []interface{}
	for _, recipientItem := range recipient {
		recipientRule = append(recipientRule, recipientItem)
	}

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.FilterLogs(opts, "Released", senderRule, recipientRule)
	if err != nil {
		return nil, err
	}
	return &BurnMintWhitelistedTokenPoolReleasedIterator{contract: _BurnMintWhitelistedTokenPool.contract, event: "Released", logs: logs, sub: sub}, nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) WatchReleased(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolReleased, sender []common.Address, recipient []common.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}
	var recipientRule []interface{}
	for _, recipientItem := range recipient {
		recipientRule = append(recipientRule, recipientItem)
	}

	logs, sub, err := _BurnMintWhitelistedTokenPool.contract.WatchLogs(opts, "Released", senderRule, recipientRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(BurnMintWhitelistedTokenPoolReleased)
				if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "Released", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPoolFilterer) ParseReleased(log types.Log) (*BurnMintWhitelistedTokenPoolReleased, error) {
	event := new(BurnMintWhitelistedTokenPoolReleased)
	if err := _BurnMintWhitelistedTokenPool.contract.UnpackLog(event, "Released", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPool) ParseLog(log types.Log) (generated.AbigenLog, error) {
	switch log.Topics[0] {
	case _BurnMintWhitelistedTokenPool.abi.Events["AllowListAdd"].ID:
		return _BurnMintWhitelistedTokenPool.ParseAllowListAdd(log)
	case _BurnMintWhitelistedTokenPool.abi.Events["AllowListRemove"].ID:
		return _BurnMintWhitelistedTokenPool.ParseAllowListRemove(log)
	case _BurnMintWhitelistedTokenPool.abi.Events["Burned"].ID:
		return _BurnMintWhitelistedTokenPool.ParseBurned(log)
	case _BurnMintWhitelistedTokenPool.abi.Events["Locked"].ID:
		return _BurnMintWhitelistedTokenPool.ParseLocked(log)
	case _BurnMintWhitelistedTokenPool.abi.Events["Minted"].ID:
		return _BurnMintWhitelistedTokenPool.ParseMinted(log)
	case _BurnMintWhitelistedTokenPool.abi.Events["OffRampAdded"].ID:
		return _BurnMintWhitelistedTokenPool.ParseOffRampAdded(log)
	case _BurnMintWhitelistedTokenPool.abi.Events["OffRampConfigured"].ID:
		return _BurnMintWhitelistedTokenPool.ParseOffRampConfigured(log)
	case _BurnMintWhitelistedTokenPool.abi.Events["OffRampRemoved"].ID:
		return _BurnMintWhitelistedTokenPool.ParseOffRampRemoved(log)
	case _BurnMintWhitelistedTokenPool.abi.Events["OnRampAdded"].ID:
		return _BurnMintWhitelistedTokenPool.ParseOnRampAdded(log)
	case _BurnMintWhitelistedTokenPool.abi.Events["OnRampConfigured"].ID:
		return _BurnMintWhitelistedTokenPool.ParseOnRampConfigured(log)
	case _BurnMintWhitelistedTokenPool.abi.Events["OnRampRemoved"].ID:
		return _BurnMintWhitelistedTokenPool.ParseOnRampRemoved(log)
	case _BurnMintWhitelistedTokenPool.abi.Events["OwnershipTransferRequested"].ID:
		return _BurnMintWhitelistedTokenPool.ParseOwnershipTransferRequested(log)
	case _BurnMintWhitelistedTokenPool.abi.Events["OwnershipTransferred"].ID:
		return _BurnMintWhitelistedTokenPool.ParseOwnershipTransferred(log)
	case _BurnMintWhitelistedTokenPool.abi.Events["Released"].ID:
		return _BurnMintWhitelistedTokenPool.ParseReleased(log)

	default:
		return nil, fmt.Errorf("abigen wrapper received unknown log topic: %v", log.Topics[0])
	}
}

func (BurnMintWhitelistedTokenPoolAllowListAdd) Topic() common.Hash {
	return common.HexToHash("0x2640d4d76caf8bf478aabfa982fa4e1c4eb71a37f93cd15e80dbc657911546d8")
}

func (BurnMintWhitelistedTokenPoolAllowListRemove) Topic() common.Hash {
	return common.HexToHash("0x800671136ab6cfee9fbe5ed1fb7ca417811aca3cf864800d127b927adedf7566")
}

func (BurnMintWhitelistedTokenPoolBurned) Topic() common.Hash {
	return common.HexToHash("0x696de425f79f4a40bc6d2122ca50507f0efbeabbff86a84871b7196ab8ea8df7")
}

func (BurnMintWhitelistedTokenPoolLocked) Topic() common.Hash {
	return common.HexToHash("0x9f1ec8c880f76798e7b793325d625e9b60e4082a553c98f42b6cda368dd60008")
}

func (BurnMintWhitelistedTokenPoolMinted) Topic() common.Hash {
	return common.HexToHash("0x9d228d69b5fdb8d273a2336f8fb8612d039631024ea9bf09c424a9503aa078f0")
}

func (BurnMintWhitelistedTokenPoolOffRampAdded) Topic() common.Hash {
	return common.HexToHash("0x395b7374909d2b54e5796f53c898ebf41d767c86c78ea86519acf2b805852d88")
}

func (BurnMintWhitelistedTokenPoolOffRampConfigured) Topic() common.Hash {
	return common.HexToHash("0xb3ba339cfbb8ef80d7a29ce5493051cb90e64fcfa85d7124efc1adfa4c68399f")
}

func (BurnMintWhitelistedTokenPoolOffRampRemoved) Topic() common.Hash {
	return common.HexToHash("0xcf91daec21e3510e2f2aea4b09d08c235d5c6844980be709f282ef591dbf420c")
}

func (BurnMintWhitelistedTokenPoolOnRampAdded) Topic() common.Hash {
	return common.HexToHash("0x0b594bb0555ff7b252e0c789ccc9d8903fec294172064308727d570505cee1ac")
}

func (BurnMintWhitelistedTokenPoolOnRampConfigured) Topic() common.Hash {
	return common.HexToHash("0x578db78e348076074dbff64a94073a83e9a65aa6766b8c75fdc89282b0e30ed6")
}

func (BurnMintWhitelistedTokenPoolOnRampRemoved) Topic() common.Hash {
	return common.HexToHash("0x7fd064821314ad863a0714a3f1229375ace6b6427ed5544b7b2ba1c47b1b5294")
}

func (BurnMintWhitelistedTokenPoolOwnershipTransferRequested) Topic() common.Hash {
	return common.HexToHash("0xed8889f560326eb138920d842192f0eb3dd22b4f139c87a2c57538e05bae1278")
}

func (BurnMintWhitelistedTokenPoolOwnershipTransferred) Topic() common.Hash {
	return common.HexToHash("0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0")
}

func (BurnMintWhitelistedTokenPoolReleased) Topic() common.Hash {
	return common.HexToHash("0x2d87480f50083e2b2759522a8fdda59802650a8055e609a7772cf70c07748f52")
}

func (_BurnMintWhitelistedTokenPool *BurnMintWhitelistedTokenPool) Address() common.Address {
	return _BurnMintWhitelistedTokenPool.address
}

type BurnMintWhitelistedTokenPoolInterface interface {
	CurrentOffRampRateLimiterState(opts *bind.CallOpts, offRamp common.Address) (RateLimiterTokenBucket, error)

	CurrentOnRampRateLimiterState(opts *bind.CallOpts, onRamp common.Address) (RateLimiterTokenBucket, error)

	GetAllowList(opts *bind.CallOpts) ([]common.Address, error)

	GetAllowListEnabled(opts *bind.CallOpts) (bool, error)

	GetArmProxy(opts *bind.CallOpts) (common.Address, error)

	GetOffRamps(opts *bind.CallOpts) ([]common.Address, error)

	GetOnRamps(opts *bind.CallOpts) ([]common.Address, error)

	GetToken(opts *bind.CallOpts) (common.Address, error)

	IsOffRamp(opts *bind.CallOpts, offRamp common.Address) (bool, error)

	IsOnRamp(opts *bind.CallOpts, onRamp common.Address) (bool, error)

	Owner(opts *bind.CallOpts) (common.Address, error)

	SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error)

	TypeAndVersion(opts *bind.CallOpts) (string, error)

	AcceptOwnership(opts *bind.TransactOpts) (*types.Transaction, error)

	ApplyAllowListUpdates(opts *bind.TransactOpts, removes []common.Address, adds []common.Address) (*types.Transaction, error)

	ApplyRampUpdates(opts *bind.TransactOpts, onRamps []TokenPoolRampUpdate, offRamps []TokenPoolRampUpdate) (*types.Transaction, error)

	LockOrBurn(opts *bind.TransactOpts, originalSender common.Address, arg1 []byte, amount *big.Int, arg3 uint64, arg4 []byte) (*types.Transaction, error)

	ReleaseOrMint(opts *bind.TransactOpts, arg0 []byte, receiver common.Address, amount *big.Int, arg3 uint64, arg4 []byte) (*types.Transaction, error)

	SetOffRampRateLimiterConfig(opts *bind.TransactOpts, offRamp common.Address, config RateLimiterConfig) (*types.Transaction, error)

	SetOnRampRateLimiterConfig(opts *bind.TransactOpts, onRamp common.Address, config RateLimiterConfig) (*types.Transaction, error)

	TransferOwnership(opts *bind.TransactOpts, to common.Address) (*types.Transaction, error)

	FilterAllowListAdd(opts *bind.FilterOpts) (*BurnMintWhitelistedTokenPoolAllowListAddIterator, error)

	WatchAllowListAdd(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolAllowListAdd) (event.Subscription, error)

	ParseAllowListAdd(log types.Log) (*BurnMintWhitelistedTokenPoolAllowListAdd, error)

	FilterAllowListRemove(opts *bind.FilterOpts) (*BurnMintWhitelistedTokenPoolAllowListRemoveIterator, error)

	WatchAllowListRemove(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolAllowListRemove) (event.Subscription, error)

	ParseAllowListRemove(log types.Log) (*BurnMintWhitelistedTokenPoolAllowListRemove, error)

	FilterBurned(opts *bind.FilterOpts, sender []common.Address) (*BurnMintWhitelistedTokenPoolBurnedIterator, error)

	WatchBurned(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolBurned, sender []common.Address) (event.Subscription, error)

	ParseBurned(log types.Log) (*BurnMintWhitelistedTokenPoolBurned, error)

	FilterLocked(opts *bind.FilterOpts, sender []common.Address) (*BurnMintWhitelistedTokenPoolLockedIterator, error)

	WatchLocked(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolLocked, sender []common.Address) (event.Subscription, error)

	ParseLocked(log types.Log) (*BurnMintWhitelistedTokenPoolLocked, error)

	FilterMinted(opts *bind.FilterOpts, sender []common.Address, recipient []common.Address) (*BurnMintWhitelistedTokenPoolMintedIterator, error)

	WatchMinted(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolMinted, sender []common.Address, recipient []common.Address) (event.Subscription, error)

	ParseMinted(log types.Log) (*BurnMintWhitelistedTokenPoolMinted, error)

	FilterOffRampAdded(opts *bind.FilterOpts) (*BurnMintWhitelistedTokenPoolOffRampAddedIterator, error)

	WatchOffRampAdded(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolOffRampAdded) (event.Subscription, error)

	ParseOffRampAdded(log types.Log) (*BurnMintWhitelistedTokenPoolOffRampAdded, error)

	FilterOffRampConfigured(opts *bind.FilterOpts) (*BurnMintWhitelistedTokenPoolOffRampConfiguredIterator, error)

	WatchOffRampConfigured(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolOffRampConfigured) (event.Subscription, error)

	ParseOffRampConfigured(log types.Log) (*BurnMintWhitelistedTokenPoolOffRampConfigured, error)

	FilterOffRampRemoved(opts *bind.FilterOpts) (*BurnMintWhitelistedTokenPoolOffRampRemovedIterator, error)

	WatchOffRampRemoved(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolOffRampRemoved) (event.Subscription, error)

	ParseOffRampRemoved(log types.Log) (*BurnMintWhitelistedTokenPoolOffRampRemoved, error)

	FilterOnRampAdded(opts *bind.FilterOpts) (*BurnMintWhitelistedTokenPoolOnRampAddedIterator, error)

	WatchOnRampAdded(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolOnRampAdded) (event.Subscription, error)

	ParseOnRampAdded(log types.Log) (*BurnMintWhitelistedTokenPoolOnRampAdded, error)

	FilterOnRampConfigured(opts *bind.FilterOpts) (*BurnMintWhitelistedTokenPoolOnRampConfiguredIterator, error)

	WatchOnRampConfigured(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolOnRampConfigured) (event.Subscription, error)

	ParseOnRampConfigured(log types.Log) (*BurnMintWhitelistedTokenPoolOnRampConfigured, error)

	FilterOnRampRemoved(opts *bind.FilterOpts) (*BurnMintWhitelistedTokenPoolOnRampRemovedIterator, error)

	WatchOnRampRemoved(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolOnRampRemoved) (event.Subscription, error)

	ParseOnRampRemoved(log types.Log) (*BurnMintWhitelistedTokenPoolOnRampRemoved, error)

	FilterOwnershipTransferRequested(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*BurnMintWhitelistedTokenPoolOwnershipTransferRequestedIterator, error)

	WatchOwnershipTransferRequested(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolOwnershipTransferRequested, from []common.Address, to []common.Address) (event.Subscription, error)

	ParseOwnershipTransferRequested(log types.Log) (*BurnMintWhitelistedTokenPoolOwnershipTransferRequested, error)

	FilterOwnershipTransferred(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*BurnMintWhitelistedTokenPoolOwnershipTransferredIterator, error)

	WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolOwnershipTransferred, from []common.Address, to []common.Address) (event.Subscription, error)

	ParseOwnershipTransferred(log types.Log) (*BurnMintWhitelistedTokenPoolOwnershipTransferred, error)

	FilterReleased(opts *bind.FilterOpts, sender []common.Address, recipient []common.Address) (*BurnMintWhitelistedTokenPoolReleasedIterator, error)

	WatchReleased(opts *bind.WatchOpts, sink chan<- *BurnMintWhitelistedTokenPoolReleased, sender []common.Address, recipient []common.Address) (event.Subscription, error)

	ParseReleased(log types.Log) (*BurnMintWhitelistedTokenPoolReleased, error)

	ParseLog(log types.Log) (generated.AbigenLog, error)

	Address() common.Address
}
