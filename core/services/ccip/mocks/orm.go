// Code generated by mockery v2.8.0. DO NOT EDIT.

package mocks

import (
	big "math/big"

	common "github.com/ethereum/go-ethereum/common"
	ccip "github.com/smartcontractkit/chainlink/core/services/ccip"

	mock "github.com/stretchr/testify/mock"
)

// ORM is an autogenerated mock type for the ORM type
type ORM struct {
	mock.Mock
}

// RelayReport provides a mock function with given fields: seqNum
func (_m *ORM) RelayReport(seqNum *big.Int) (ccip.RelayReport, error) {
	ret := _m.Called(seqNum)

	var r0 ccip.RelayReport
	if rf, ok := ret.Get(0).(func(*big.Int) ccip.RelayReport); ok {
		r0 = rf(seqNum)
	} else {
		r0 = ret.Get(0).(ccip.RelayReport)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*big.Int) error); ok {
		r1 = rf(seqNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Requests provides a mock function with given fields: sourceChainId, destChainId, minSeqNum, maxSeqNum, status, executor, options
func (_m *ORM) Requests(sourceChainId *big.Int, destChainId *big.Int, minSeqNum *big.Int, maxSeqNum *big.Int, status ccip.RequestStatus, executor *common.Address, options []byte) ([]*ccip.Request, error) {
	ret := _m.Called(sourceChainId, destChainId, minSeqNum, maxSeqNum, status, executor, options)

	var r0 []*ccip.Request
	if rf, ok := ret.Get(0).(func(*big.Int, *big.Int, *big.Int, *big.Int, ccip.RequestStatus, *common.Address, []byte) []*ccip.Request); ok {
		r0 = rf(sourceChainId, destChainId, minSeqNum, maxSeqNum, status, executor, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ccip.Request)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*big.Int, *big.Int, *big.Int, *big.Int, ccip.RequestStatus, *common.Address, []byte) error); ok {
		r1 = rf(sourceChainId, destChainId, minSeqNum, maxSeqNum, status, executor, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetExpiredRequests provides a mock function with given fields: sourceChainId, destChainId, expiryTimeoutSeconds, fromStatus, toStatus
func (_m *ORM) ResetExpiredRequests(sourceChainId *big.Int, destChainId *big.Int, expiryTimeoutSeconds int, fromStatus ccip.RequestStatus, toStatus ccip.RequestStatus) error {
	ret := _m.Called(sourceChainId, destChainId, expiryTimeoutSeconds, fromStatus, toStatus)

	var r0 error
	if rf, ok := ret.Get(0).(func(*big.Int, *big.Int, int, ccip.RequestStatus, ccip.RequestStatus) error); ok {
		r0 = rf(sourceChainId, destChainId, expiryTimeoutSeconds, fromStatus, toStatus)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveRelayReport provides a mock function with given fields: report
func (_m *ORM) SaveRelayReport(report ccip.RelayReport) error {
	ret := _m.Called(report)

	var r0 error
	if rf, ok := ret.Get(0).(func(ccip.RelayReport) error); ok {
		r0 = rf(report)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveRequest provides a mock function with given fields: request
func (_m *ORM) SaveRequest(request *ccip.Request) error {
	ret := _m.Called(request)

	var r0 error
	if rf, ok := ret.Get(0).(func(*ccip.Request) error); ok {
		r0 = rf(request)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateRequestSetStatus provides a mock function with given fields: sourceChainId, destChainId, seqNums, status
func (_m *ORM) UpdateRequestSetStatus(sourceChainId *big.Int, destChainId *big.Int, seqNums []*big.Int, status ccip.RequestStatus) error {
	ret := _m.Called(sourceChainId, destChainId, seqNums, status)

	var r0 error
	if rf, ok := ret.Get(0).(func(*big.Int, *big.Int, []*big.Int, ccip.RequestStatus) error); ok {
		r0 = rf(sourceChainId, destChainId, seqNums, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateRequestStatus provides a mock function with given fields: sourceChainId, destChainId, minSeqNum, maxSeqNum, status
func (_m *ORM) UpdateRequestStatus(sourceChainId *big.Int, destChainId *big.Int, minSeqNum *big.Int, maxSeqNum *big.Int, status ccip.RequestStatus) error {
	ret := _m.Called(sourceChainId, destChainId, minSeqNum, maxSeqNum, status)

	var r0 error
	if rf, ok := ret.Get(0).(func(*big.Int, *big.Int, *big.Int, *big.Int, ccip.RequestStatus) error); ok {
		r0 = rf(sourceChainId, destChainId, minSeqNum, maxSeqNum, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
