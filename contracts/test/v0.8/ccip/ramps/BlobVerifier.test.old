import hre, { ethers } from 'hardhat'
import {
  expectGasWithinDeviation,
  numToBytes32,
  publicAbi,
  stringToBytes,
} from '../../../test-helpers/helpers'
import { expect } from 'chai'
import {
  BigNumber,
  Contract,
  ContractFactory,
  ContractReceipt,
  ContractTransaction,
} from 'ethers'
import { Roles, getUsers } from '../../../test-helpers/setup'
import {
  SimpleMessageReceiver,
  MockERC20,
  NativeTokenPool,
  MockAFN,
  MockAggregator,
} from '../../../../typechain'
import { Artifact } from 'hardhat/types'
import { evmRevert } from '../../../test-helpers/matchers'
import {
  Any2EVMTollMessage,
  encodeRelayReport,
  ExecutionReport,
  MerkleMultiTree,
  messageDeepEqual,
  RelayReport,
} from '../../../test-helpers/ccip/ccip'
import { constants } from 'ethers'
import { GAS } from '../../../test-helpers/ccip/gas-measurements'
const { deployContract } = hre.waffle

let roles: Roles

// This has to be ethers.Contract because of an issue with
// `address.call(abi.encodeWithSelector(...))` using typechain artifacts.
let blobVerifier: Contract
let router: Contract
let afn: MockAFN
let sourceToken1: MockERC20
let destinationToken1: MockERC20
let sourceToken2: MockERC20
let destinationToken2: MockERC20
let receiver: SimpleMessageReceiver
let pool1: NativeTokenPool
let pool2: NativeTokenPool
let priceFeed1: MockAggregator

let MockAFNArtifact: Artifact
let TokenArtifact: Artifact
let PoolArtifact: Artifact
let PriceFeedArtifact: Artifact
let SimpleMessageReceiverArtifact: Artifact
let blobVerifierHelperFactory: ContractFactory
let routerFactory: ContractFactory

const priceFeed1LatestAnswer: number = 100
const sourceChainId: number = 123
const destinationChainId: number = 234
const initialExecutionDelay: number = 0
const maxTokenLength: number = 10
const initialConfig = {
  executionFeeJuels: 1,
  executionDelaySeconds: initialExecutionDelay,
  maxDataSize: 1000,
  maxTokensLength: maxTokenLength,
}
let bucketRate: BigNumber
let bucketCapactiy: BigNumber
let maxTimeBetweenAFNSignals: BigNumber

async function executionValidationFail(
  ramp: Contract,
  messages: Any2EVMTollMessage[],
  revertReason: string,
  takeFees: boolean = false,
) {
  const tree = new MerkleMultiTree(messages)
  await ramp
    .connect(roles.defaultAccount)
    .report(encodeRelayReport(tree.generateRelayReport()))
  await evmRevert(
    ramp
      .connect(roles.defaultAccount)
      .executeTransaction(tree.generateExecutionReport([0]), takeFees),
    revertReason,
  )
}

beforeEach(async () => {
  const users = await getUsers()
  roles = users.roles
})

describe('BlobVerifier', () => {
  beforeEach(async () => {
    MockAFNArtifact = await hre.artifacts.readArtifact('MockAFN')
    TokenArtifact = await hre.artifacts.readArtifact('MockERC20')
    PoolArtifact = await hre.artifacts.readArtifact('NativeTokenPool')
    PriceFeedArtifact = await hre.artifacts.readArtifact('MockAggregator')
    blobVerifierHelperFactory = await hre.ethers.getContractFactory(
      'BlobVerifierHelper',
    )
    routerFactory = await hre.ethers.getContractFactory(
      'Any2EVMTollOffRampRouter',
    )

    SimpleMessageReceiverArtifact = await hre.artifacts.readArtifact(
      'SimpleMessageReceiver',
    )
    bucketRate = BigNumber.from('10000000000000000')
    bucketCapactiy = BigNumber.from('100000000000000000')
    const mintAmount = BigNumber.from('100000000000000000000')
    maxTimeBetweenAFNSignals = BigNumber.from(60).mul(60) // 1 hour
    sourceToken1 = <MockERC20>(
      await deployContract(roles.defaultAccount, TokenArtifact, [
        'LINK sourceToken1',
        'LINK',
        await roles.defaultAccount.getAddress(),
        mintAmount,
      ])
    )
    sourceToken2 = <MockERC20>(
      await deployContract(roles.defaultAccount, TokenArtifact, [
        'LINK sourceToken2',
        'LINK',
        await roles.defaultAccount.getAddress(),
        mintAmount,
      ])
    )
    destinationToken1 = <MockERC20>(
      await deployContract(roles.defaultAccount, TokenArtifact, [
        'LINK destinationToken1',
        'LINK',
        await roles.defaultAccount.getAddress(),
        mintAmount,
      ])
    )
    destinationToken2 = <MockERC20>(
      await deployContract(roles.defaultAccount, TokenArtifact, [
        'LINK destinationToken2',
        'LINK',
        await roles.defaultAccount.getAddress(),
        mintAmount,
      ])
    )
    let bucketConfig = {
      rate: bucketRate,
      capacity: bucketCapactiy,
    }
    pool1 = <NativeTokenPool>(
      await deployContract(roles.defaultAccount, PoolArtifact, [
        destinationToken1.address,
        bucketConfig,
        bucketConfig,
      ])
    )
    pool2 = <NativeTokenPool>(
      await deployContract(roles.defaultAccount, PoolArtifact, [
        destinationToken2.address,
        bucketConfig,
        bucketConfig,
      ])
    )
    await destinationToken1
      .connect(roles.defaultAccount)
      .transfer(pool1.address, mintAmount.div(2))
    await destinationToken2
      .connect(roles.defaultAccount)
      .transfer(pool2.address, mintAmount.div(2))
    priceFeed1 = <MockAggregator>(
      await deployContract(roles.defaultAccount, PriceFeedArtifact)
    )
    await priceFeed1
      .connect(roles.defaultAccount)
      .setLatestAnswer(priceFeed1LatestAnswer)
    afn = <MockAFN>await deployContract(roles.defaultAccount, MockAFNArtifact)
    blobVerifier = await blobVerifierHelperFactory
      .connect(roles.defaultAccount)
      .deploy(
        sourceChainId,
        destinationChainId,
        [sourceToken1.address, sourceToken2.address],
        [pool1.address, pool2.address],
        [priceFeed1.address, constants.AddressZero],
        afn.address,
        maxTimeBetweenAFNSignals,
        initialExecutionDelay,
        maxTokenLength,
      )
    router = await routerFactory
      .connect(roles.defaultAccount)
      .deploy([blobVerifier.address])
    await blobVerifier.connect(roles.defaultAccount).setRouter(router.address)
    await pool1
      .connect(roles.defaultAccount)
      .setOffRamp(blobVerifier.address, true)
    await pool2
      .connect(roles.defaultAccount)
      .setOffRamp(blobVerifier.address, true)
    receiver = <SimpleMessageReceiver>(
      await deployContract(roles.defaultAccount, SimpleMessageReceiverArtifact)
    )
  })

  it('has a limited public interface [ @skip-coverage ]', async () => {
    publicAbi(blobVerifier, [
      // Ramp
      'CHAIN_ID',
      'executeTransaction',
      'withdrawAccumulatedFees',
      'merkleRoot',
      'getMerkleRoot',
      'getExecuted',
      'getLastReport',
      'getOffRampConfig',
      'setOffRampConfig',
      // HealthChecker
      'setAFN',
      'getAFN',
      'setMaxSecondsWithoutAFNHeartbeat',
      'getMaxSecondsWithoutAFNHeartbeat',
      'isHealthy',
      // OffRampHelper
      'report',
      // OCR2Abstract
      'setConfig',
      'latestConfigDetails',
      'latestConfigDigestAndEpoch',
      'transmit',
      // OCR2Base
      'transmitters',
      // TypeAndVersionInterface
      'typeAndVersion',
      // Ownership
      'owner',
      'transferOwnership',
      'acceptOwnership',
      // Pausable
      'paused',
      'pause',
      'unpause',
    ])
  })

  describe('#constructor', () => {
    it('should deploy correctly', async () => {
      const owner = await roles.defaultAccount.getAddress()
      await expect(await blobVerifier.SOURCE_CHAIN_ID()).to.equal(sourceChainId)
      await expect(await blobVerifier.owner()).to.equal(owner)
      await expect(await blobVerifier.getOffRampConfig()).to.deep.equal([
        BigNumber.from(initialConfig.executionFeeJuels),
        BigNumber.from(initialConfig.executionDelaySeconds),
        BigNumber.from(initialConfig.maxDataSize),
        BigNumber.from(initialConfig.maxTokensLength),
      ])
      await expect(await pool1.owner()).to.equal(owner)
      await expect(await pool1.isOffRamp(blobVerifier.address)).to.equal(true)
      await expect(await pool1.getToken()).to.equal(destinationToken1.address)
    })
  })

  describe('#merkleRoot', () => {
    let messages: Array<Any2EVMTollMessage>
    let tree: MerkleMultiTree

    beforeEach(async () => {
      const receiver = await roles.oracleNode1.getAddress()
      messages = [
        {
          sourceChainId: BigNumber.from(1),
          sequenceNumber: BigNumber.from(1),
          sender: receiver,
          tokens: [],
          amounts: [],
          receiver: receiver,
          data: ethers.constants.HashZero,
          feeToken: sourceToken1.address,
          feeTokenAmount: 0,
          gasLimit: 0,
        },
        {
          sourceChainId: BigNumber.from(1),
          sequenceNumber: BigNumber.from(2),
          sender: receiver,
          tokens: [],
          amounts: [],
          receiver: receiver,
          data: ethers.constants.HashZero,
          feeToken: sourceToken1.address,
          feeTokenAmount: 0,
          gasLimit: 0,
        },
        {
          sourceChainId: BigNumber.from(1),
          sequenceNumber: BigNumber.from(3),
          sender: receiver,
          tokens: [],
          amounts: [],
          receiver: receiver,
          data: ethers.constants.HashZero,
          feeToken: sourceToken1.address,
          feeTokenAmount: 0,
          gasLimit: 0,
        },
        {
          sourceChainId: BigNumber.from(1),
          sequenceNumber: BigNumber.from(4),
          sender: receiver,
          tokens: [],
          amounts: [],
          receiver: receiver,
          data: ethers.constants.HashZero,
          feeToken: sourceToken1.address,
          feeTokenAmount: 0,
          gasLimit: 0,
        },
      ]
      tree = new MerkleMultiTree(messages)
    })

    describe('contract root verification', async () => {
      it('leaf 1', async () => {
        const execReport: ExecutionReport = tree.generateExecutionReport([0])
        const response = await blobVerifier.merkleRoot(execReport)
        expect(response).to.equal(tree.getRoot())
      })

      it('2 leaves', async () => {
        const indices = [0, 3]
        const execReport: ExecutionReport =
          tree.generateExecutionReport(indices)
        const response = await blobVerifier.merkleRoot(execReport)
        expect(response).to.equal(tree.getRoot())
      })

      it('3 leaves', async () => {
        const indices = [0, 1, 3]
        const execReport: ExecutionReport =
          tree.generateExecutionReport(indices)
        const response = await blobVerifier.merkleRoot(execReport)
        expect(response).to.equal(tree.getRoot())
      })

      it('4 leaves', async () => {
        const indices = [0, 1, 2, 3]
        const execReport: ExecutionReport =
          tree.generateExecutionReport(indices)
        const response = await blobVerifier.merkleRoot(execReport)
        expect(response).to.equal(tree.getRoot())
      })
    })
  })

  describe('#report', () => {
    describe('failure', () => {
      let report: RelayReport
      beforeEach(async () => {
        report = {
          merkleRoot: numToBytes32(1),
          minSequenceNumber: BigNumber.from(2),
          maxSequenceNumber: BigNumber.from(3),
        }
      })

      it('reverts when paused', async () => {
        await blobVerifier.connect(roles.defaultAccount).pause()
        await evmRevert(
          blobVerifier.connect(roles.defaultAccount).report(stringToBytes('')),
          'Pausable: paused',
        )
      })

      it('fails whenn the AFN signal is bad', async () => {
        await afn.voteBad()
        await evmRevert(
          blobVerifier.connect(roles.defaultAccount).report(stringToBytes('')),
          'BadAFNSignal()',
        )
      })

      it('fails when the AFN signal is stale', async () => {
        await afn.setTimestamp(BigNumber.from(1))
        await evmRevert(
          blobVerifier.connect(roles.defaultAccount).report(stringToBytes('')),
          'StaleAFNHeartbeat()',
        )
      })

      it('reverts when the minSequenceNumber is greater than the maxSequenceNumber', async () => {
        report.maxSequenceNumber = BigNumber.from(1)
        await evmRevert(
          blobVerifier
            .connect(roles.defaultAccount)
            .report(encodeRelayReport(report)),
          'RelayReportError()',
        )
      })

      it('reverts when the minSequenceNumber is not 1 greater than the previous report maxSequenceNumber', async () => {
        await blobVerifier
          .connect(roles.defaultAccount)
          .report(encodeRelayReport(report))
        report = {
          merkleRoot: numToBytes32(2),
          minSequenceNumber: BigNumber.from(3),
          maxSequenceNumber: BigNumber.from(4),
        }
        await evmRevert(
          blobVerifier
            .connect(roles.defaultAccount)
            .report(encodeRelayReport(report)),
          `SequenceError(3, 3)`,
        )
      })
    })

    describe('success', () => {
      let report: RelayReport
      let root: string
      let response: ContractTransaction
      let gasUsed: BigNumber
      beforeEach(async () => {
        gasUsed = BigNumber.from(0)
        root = numToBytes32(1)
        report = {
          merkleRoot: root,
          minSequenceNumber: BigNumber.from(1),
          maxSequenceNumber: BigNumber.from(2),
        }
        response = await blobVerifier
          .connect(roles.defaultAccount)
          .report(encodeRelayReport(report))
        gasUsed = gasUsed.add((await response.wait()).gasUsed)
      })
      it('GASTEST [ @skip-coverage ]', async () => {
        expectGasWithinDeviation(gasUsed, GAS.OffRamp.report)
      })
      it('stores the root', async () => {
        const stored = await blobVerifier.getMerkleRoot(root)
        expect(stored).to.not.equal(0)
      })
      it('stores the report in s_lastReport', async () => {
        const response = await blobVerifier.getLastReport()
        expect(response.merkleRoot).to.equal(root)
        expect(response.minSequenceNumber).to.equal(report.minSequenceNumber)
        expect(response.maxSequenceNumber).to.equal(report.maxSequenceNumber)
      })
      it('emits a ReportAccepted event', async () => {
        expect(response)
          .to.emit(blobVerifier, 'ReportAccepted')
          .withArgs([root, report.minSequenceNumber, report.maxSequenceNumber])
      })
    })
  })

  describe('#executeTransaction', () => {
    let sequenceNumber: BigNumber
    let sourceId: BigNumber
    let sender: string
    let messagedata: string
    let amount: BigNumber
    let message: Any2EVMTollMessage

    beforeEach(async () => {
      sequenceNumber = BigNumber.from(1)
      sourceId = BigNumber.from(sourceChainId)
      sender = await roles.oracleNode.getAddress()
      messagedata = stringToBytes('Message')
      amount = BigNumber.from('10000000000')
      message = {
        sequenceNumber: sequenceNumber,
        sourceChainId: sourceId,
        sender: sender,
        receiver: receiver.address,
        data: messagedata,
        tokens: [sourceToken1.address, sourceToken2.address],
        amounts: [amount, amount],
        feeToken: sourceToken1.address,
        feeTokenAmount: 0,
        gasLimit: 0,
      }
    })

    describe('failure', () => {
      describe('verifyMerkleProof failures', () => {
        let tree: MerkleMultiTree
        let relayReport: RelayReport
        let executionReport: ExecutionReport

        beforeEach(async () => {
          const sequenceNumber2 = BigNumber.from(2)
          const message2: Any2EVMTollMessage = {
            sourceChainId: sourceId,
            sequenceNumber: sequenceNumber2,
            sender: sender,
            receiver: receiver.address,
            data: messagedata,
            tokens: [sourceToken1.address],
            amounts: [BigNumber.from('9999999')],
            feeToken: sourceToken1.address,
            feeTokenAmount: 0,
            gasLimit: 0,
          }
          tree = new MerkleMultiTree([message, message2])
          relayReport = tree.generateRelayReport()
          await blobVerifier
            .connect(roles.defaultAccount)
            .report(encodeRelayReport(relayReport))
          executionReport = tree.generateExecutionReport([0])
        })

        it('fails when the payload is wrong', async () => {
          executionReport.messages[0].data = stringToBytes('loremipsum')

          await evmRevert(
            blobVerifier
              .connect(roles.defaultAccount)
              .executeTransaction(executionReport, false),
          )
        })

        it('fails when the proofs is wrong', async () => {
          executionReport.proofs = []
          await evmRevert(
            blobVerifier
              .connect(roles.defaultAccount)
              .executeTransaction(executionReport, false),
          )
        })

        it('fails when the execution delay has not yet passed', async () => {
          let newConfig = initialConfig
          newConfig.executionDelaySeconds = 60 * 60
          await blobVerifier
            .connect(roles.defaultAccount)
            .setOffRampConfig(newConfig)
          await evmRevert(
            blobVerifier
              .connect(roles.defaultAccount)
              .executeTransaction(executionReport, false),
            `ExecutionDelayError()`,
          )
        })
      })
      describe('validation fails', () => {
        it('fails if the receiver is the ramp', async () => {
          message.receiver = blobVerifier.address
          await executionValidationFail(
            blobVerifier,
            [message],
            `InvalidReceiver("${message.receiver}")`,
          )
        })
        it('fails if the receiver is the pool1', async () => {
          message.receiver = pool1.address
          await executionValidationFail(
            blobVerifier,
            [message],
            `InvalidReceiver("${message.receiver}")`,
          )
        })
        it('fails when the message is already executed', async () => {
          const tree = new MerkleMultiTree([message])
          await blobVerifier
            .connect(roles.defaultAccount)
            .report(encodeRelayReport(tree.generateRelayReport()))
          const execReport = tree.generateExecutionReport([0])
          await blobVerifier
            .connect(roles.defaultAccount)
            .executeTransaction(execReport, false)
          await evmRevert(
            blobVerifier
              .connect(roles.defaultAccount)
              .executeTransaction(execReport, false),
            `AlreadyExecuted(${message.sequenceNumber})`,
          )
        })
        it('should fail if sent from an unsupported source chain', async () => {
          message.sourceChainId = BigNumber.from(999)
          await executionValidationFail(
            blobVerifier,
            [message],
            `InvalidSourceChain(${message.sourceChainId})`,
          )
        })
        it('should fail if the number of tokens sent is not 1', async () => {
          message.tokens.push(await roles.oracleNode.getAddress())
          await executionValidationFail(
            blobVerifier,
            [message],
            `UnsupportedNumberOfTokens()`,
          )
        })
        it('should fail if the number of amounts of tokens to send is not 1', async () => {
          message.amounts.push(BigNumber.from(50000))
          await executionValidationFail(
            blobVerifier,
            [message],
            `UnsupportedNumberOfTokens()`,
          )
        })
        it('should fail if sent using an unsupported source token', async () => {
          message.tokens[0] = await roles.oracleNode2.getAddress()
          await executionValidationFail(
            blobVerifier,
            [message],
            `UnsupportedToken("${message.tokens[0]}")`,
          )
        })
        it('should fail if sending more tokens than the tokenBucket allows', async () => {
          message.amounts[0] = bucketCapactiy.add(1)
          await executionValidationFail(
            blobVerifier,
            [message],
            `ExceedsTokenLimit(${bucketCapactiy}, ${message.amounts[0]})`,
          )
        })
        it('should fail if the contract is paused', async () => {
          const tree = new MerkleMultiTree([message])
          await blobVerifier
            .connect(roles.defaultAccount)
            .report(encodeRelayReport(tree.generateRelayReport()))
          await blobVerifier.connect(roles.defaultAccount).pause()
          await evmRevert(
            blobVerifier
              .connect(roles.defaultAccount)
              .executeTransaction(tree.generateExecutionReport([0]), false),
            `Pausable: paused`,
          )
        })
        it('fails when the AFN signal is bad', async () => {
          const tree = new MerkleMultiTree([message])
          await blobVerifier
            .connect(roles.defaultAccount)
            .report(encodeRelayReport(tree.generateRelayReport()))
          await afn.voteBad()
          await evmRevert(
            blobVerifier
              .connect(roles.defaultAccount)
              .executeTransaction(tree.generateExecutionReport([0]), false),
            `BadAFNSignal()`,
          )
        })
        it('fails when the AFN signal is stale', async () => {
          const tree = new MerkleMultiTree([message])
          await blobVerifier
            .connect(roles.defaultAccount)
            .report(encodeRelayReport(tree.generateRelayReport()))
          await afn.setTimestamp(BigNumber.from(1))
          await evmRevert(
            blobVerifier
              .connect(roles.defaultAccount)
              .executeTransaction(tree.generateExecutionReport([0]), false),
            `StaleAFNHeartbeat()`,
          )
        })
      })
      describe('fee taking fails', () => {
        it('fails if the price feed does not exist', async () => {
          const tree = new MerkleMultiTree([message])
          await blobVerifier
            .connect(roles.defaultAccount)
            .report(encodeRelayReport(tree.generateRelayReport()))
          await blobVerifier
            .connect(roles.defaultAccount)
            .removeFeed(sourceToken1.address, priceFeed1.address)
          await evmRevert(
            blobVerifier
              .connect(roles.defaultAccount)
              .executeTransaction(tree.generateExecutionReport([0]), true),
            `FeeError()`,
          )
        })
        it('fails if the fee exceeds the amount sent', async () => {
          message.amounts[0] = 1
          await executionValidationFail(
            blobVerifier,
            [message],
            `panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)`,
            true,
          )
        })
      })
    })

    describe('success - 2 tokens', () => {
      let tx: ContractTransaction
      let tree: MerkleMultiTree
      beforeEach(async () => {
        tree = new MerkleMultiTree([message])
        await blobVerifier
          .connect(roles.defaultAccount)
          .report(encodeRelayReport(tree.generateRelayReport()))
      })
      describe('without fees', () => {
        beforeEach(async () => {
          tx = await blobVerifier
            .connect(roles.defaultAccount)
            .executeTransaction(tree.generateExecutionReport([0]), false)
        })

        describe('GASTEST', () => {
          it('GASTEST - contract receiver execution [ @skip-coverage ]', async () => {
            expectGasWithinDeviation(
              (await tx.wait()).gasUsed,
              GAS.OffRamp.executeTransaction.ONE_MESSAGE.TWO_TOKENS.NO_FEES
                .CONTRACT_RECEIVER,
            )
          })

          it('GASTEST - EOA receiver [ @skip-coverage ]', async () => {
            const nextSequenceNumber = sequenceNumber.add(1)
            message.receiver = await roles.consumer.getAddress()
            message.sequenceNumber = nextSequenceNumber
            message.data = []
            const newTree: MerkleMultiTree = new MerkleMultiTree([message])
            await blobVerifier
              .connect(roles.defaultAccount)
              .report(encodeRelayReport(newTree.generateRelayReport()))
            tx = await blobVerifier
              .connect(roles.oracleNode)
              .executeTransaction(newTree.generateExecutionReport([0]), true)
            expectGasWithinDeviation(
              (await tx.wait()).gasUsed,
              GAS.OffRamp.executeTransaction.ONE_MESSAGE.TWO_TOKENS.NO_FEES
                .EOA_RECEIVER,
            )
          })
        })

        it('should set s_executed to true', async () => {
          expect(await blobVerifier.getExecuted(message.sequenceNumber)).to.be
            .true
        })
        it('should deliver the message to the receiver', async () => {
          messageDeepEqual(await receiver.getMessage(), message)
        })
        it('should send the funds to the receiver contract', async () => {
          expect(await destinationToken1.balanceOf(receiver.address)).to.equal(
            message.amounts[0],
          )
          expect(await destinationToken2.balanceOf(receiver.address)).to.equal(
            message.amounts[1],
          )
        })
        it('should emit a CrossChainMessageExecuted event', async () => {
          expect(tx)
            .to.emit(blobVerifier, 'CrossChainMessageExecuted')
            .withArgs(message.sequenceNumber)
        })
      })
      describe('with fees', () => {
        beforeEach(async () => {
          tx = await blobVerifier
            .connect(roles.oracleNode)
            .executeTransaction(tree.generateExecutionReport([0]), true)
        })

        describe('GASTEST', () => {
          it('GASTEST - contract receiver execution [ @skip-coverage ]', async () => {
            expectGasWithinDeviation(
              (await tx.wait()).gasUsed,
              GAS.OffRamp.executeTransaction.ONE_MESSAGE.TWO_TOKENS.FEES
                .CONTRACT_RECEIVER,
            )
          })

          it('GASTEST - EOA receiver [ @skip-coverage ]', async () => {
            const nextSequenceNumber = sequenceNumber.add(1)
            message.receiver = await roles.consumer.getAddress()
            message.sequenceNumber = nextSequenceNumber
            message.data = []
            const newTree: MerkleMultiTree = new MerkleMultiTree([message])
            await blobVerifier
              .connect(roles.defaultAccount)
              .report(encodeRelayReport(newTree.generateRelayReport()))
            tx = await blobVerifier
              .connect(roles.oracleNode)
              .executeTransaction(newTree.generateExecutionReport([0]), true)
            expectGasWithinDeviation(
              (await tx.wait()).gasUsed,
              GAS.OffRamp.executeTransaction.ONE_MESSAGE.TWO_TOKENS.FEES
                .EOA_RECEIVER,
            )

            expect(tx)
              .to.emit(blobVerifier, 'CrossChainMessageExecuted')
              .withArgs(message.sequenceNumber)
          })
        })

        it('should set s_executed to true', async () => {
          expect(await blobVerifier.getExecuted(message.sequenceNumber)).to.be
            .true
        })
        it('should deliver the message to the receiver', async () => {
          message.amounts[0] = amount.sub(priceFeed1LatestAnswer)
          messageDeepEqual(await receiver.getMessage(), message)
        })
        it('should mint fee funds to the executor', async () => {
          expect(
            await destinationToken1.balanceOf(
              await roles.oracleNode.getAddress(),
            ),
          ).to.equal(priceFeed1LatestAnswer)
          await expect(tx)
            .to.emit(pool1, 'Released')
            .withArgs(
              blobVerifier.address,
              await roles.oracleNode.getAddress(),
              priceFeed1LatestAnswer,
            )
        })
        it('should not extract a fee if fee is zero', async () => {
          let newConfig = initialConfig
          newConfig.executionFeeJuels = 0
          newConfig.executionDelaySeconds = 0
          await blobVerifier
            .connect(roles.defaultAccount)
            .setOffRampConfig(newConfig)
          const newSequenceNumber = message.sequenceNumber.add(1)
          message.sequenceNumber = newSequenceNumber
          const newTree: MerkleMultiTree = new MerkleMultiTree([message])
          await blobVerifier
            .connect(roles.defaultAccount)
            .report(encodeRelayReport(newTree.generateRelayReport()))
          tx = await blobVerifier
            .connect(roles.oracleNode)
            .executeTransaction(newTree.generateExecutionReport([0]), true)

          const receipt: ContractReceipt = await tx.wait()
          for (let i = 0; i < receipt.logs.length; i++) {
            const log = receipt.logs[i]
            if (log.address == pool1.address) {
              const parsedLog = pool1.interface.parseLog(log)
              // ensure that no Released events are emitted with the executor as recipient
              expect(parsedLog.args.recipient).to.not.equal(
                await roles.oracleNode.getAddress(),
              )
            }
          }
        })
        it('should send the funds to the receiver contract', async () => {
          const amountAfterFee = BigNumber.from(message.amounts[0]).sub(
            priceFeed1LatestAnswer,
          )
          expect(await destinationToken1.balanceOf(receiver.address)).to.equal(
            amountAfterFee,
          )
          expect(await destinationToken2.balanceOf(receiver.address)).to.equal(
            message.amounts[1],
          )
        })
        it('should emit a CrossChainMessageExecuted event', async () => {
          expect(tx)
            .to.emit(blobVerifier, 'CrossChainMessageExecuted')
            .withArgs(message.sequenceNumber)
        })
      })
    })

    describe('GASTEST - Tree of 20 [ @skip-coverage ]', () => {
      describe('with no tokens', () => {
        let messages: Any2EVMTollMessage[] = []
        let tree: MerkleMultiTree
        let relayReport: RelayReport
        let executionReport: ExecutionReport
        beforeEach(async () => {
          const lastReport: RelayReport = await blobVerifier.getLastReport()
          for (let i = 0; i < 20; i++) {
            const tempReceiver = <SimpleMessageReceiver>(
              await deployContract(
                roles.defaultAccount,
                SimpleMessageReceiverArtifact,
              )
            )
            messages.push({
              sequenceNumber: lastReport.maxSequenceNumber.add(
                BigNumber.from(i + 1),
              ),
              sourceChainId: BigNumber.from(sourceChainId),
              sender: await roles.defaultAccount.getAddress(),
              tokens: [],
              amounts: [],
              receiver: tempReceiver.address,
              data: ethers.utils.defaultAbiCoder.encode(
                ['string'],
                [`no tokens message ${i + 1}`],
              ),
              feeToken: sourceToken1.address,
              feeTokenAmount: 0,
              gasLimit: 0,
            })
          }

          tree = new MerkleMultiTree(messages)
          relayReport = tree.generateRelayReport()
          await blobVerifier
            .connect(roles.defaultAccount)
            .report(encodeRelayReport(relayReport))
        })

        it('GASTEST - executing 10 messages', async () => {
          const messageIndices = [...Array(10).keys()]
          executionReport = tree.generateExecutionReport(messageIndices)

          const tx = await blobVerifier
            .connect(roles.defaultAccount)
            .executeTransaction(executionReport, false)
          const receipt: ContractReceipt = await tx.wait()
          expectGasWithinDeviation(
            receipt.gasUsed,
            GAS.OffRamp.executeTransaction.TEN_MESSAGES.NO_FEES.NO_TOKENS,
          )
        })
      })

      describe('with 1 token', () => {
        let messages: Any2EVMTollMessage[] = []
        let tree: MerkleMultiTree
        let relayReport: RelayReport
        let executionReport: ExecutionReport
        beforeEach(async () => {
          const lastReport: RelayReport = await blobVerifier.getLastReport()
          for (let i = 0; i < 20; i++) {
            const tempReceiver = <SimpleMessageReceiver>(
              await deployContract(
                roles.defaultAccount,
                SimpleMessageReceiverArtifact,
              )
            )
            messages.push({
              sequenceNumber: lastReport.maxSequenceNumber.add(
                BigNumber.from(i + 1),
              ),
              sourceChainId: BigNumber.from(sourceChainId),
              sender: await roles.defaultAccount.getAddress(),
              tokens: [sourceToken1.address],
              amounts: [1],
              receiver: tempReceiver.address,
              data: ethers.utils.defaultAbiCoder.encode(
                ['string'],
                [`with 1 token message ${i + 1}`],
              ),
              feeToken: sourceToken1.address,
              feeTokenAmount: 0,
              gasLimit: 0,
            })
          }

          tree = new MerkleMultiTree(messages)
          relayReport = tree.generateRelayReport()
          await blobVerifier
            .connect(roles.defaultAccount)
            .report(encodeRelayReport(relayReport))
        })

        it('GASTEST - executing 10 messages', async () => {
          const messageIndices = [...Array(10).keys()]
          executionReport = tree.generateExecutionReport(messageIndices)

          const tx = await blobVerifier
            .connect(roles.defaultAccount)
            .executeTransaction(executionReport, false)
          const receipt: ContractReceipt = await tx.wait()
          expectGasWithinDeviation(
            receipt.gasUsed,
            GAS.OffRamp.executeTransaction.TEN_MESSAGES.NO_FEES.ONE_TOKEN,
          )
        })
      })
    })
  })

  describe('#pause', () => {
    it('owner can pause ramp', async () => {
      const account = roles.defaultAccount
      await expect(blobVerifier.connect(account).pause())
        .to.emit(blobVerifier, 'Paused')
        .withArgs(await account.getAddress())
    })

    it('unknown account cannot pause pool1', async function () {
      const account = roles.stranger
      await expect(blobVerifier.connect(account).pause()).to.be.revertedWith(
        'Only callable by owner',
      )
    })
  })

  describe('#unpause', () => {
    beforeEach(async () => {
      await blobVerifier.connect(roles.defaultAccount).pause()
    })

    it('owner can unpause ramp', async () => {
      const account = roles.defaultAccount
      await expect(blobVerifier.connect(account).unpause())
        .to.emit(blobVerifier, 'Unpaused')
        .withArgs(await account.getAddress())
    })

    it('unknown account cannot unpause pool1', async function () {
      const account = roles.stranger
      await expect(blobVerifier.connect(account).unpause()).to.be.revertedWith(
        'Only callable by owner',
      )
    })
  })

  describe('#setOffRampConfig', () => {
    it('can only be called by the owner', async () => {
      await evmRevert(
        blobVerifier.connect(roles.stranger).setOffRampConfig(initialConfig),
        'Only callable by owner',
      )
    })

    it('sets the config', async () => {
      let newConfig = initialConfig
      newConfig.executionDelaySeconds = newConfig.executionDelaySeconds * 2
      newConfig.executionFeeJuels = newConfig.executionFeeJuels * 2
      newConfig.maxDataSize = newConfig.maxDataSize * 2
      newConfig.maxTokensLength = newConfig.maxTokensLength * 2
      const tx = await blobVerifier
        .connect(roles.defaultAccount)
        .setOffRampConfig(newConfig)
      await expect(tx)
        .to.emit(blobVerifier, 'OffRampConfigSet')
        .withArgs([
          newConfig.executionFeeJuels,
          newConfig.executionDelaySeconds,
          newConfig.maxDataSize,
          newConfig.maxTokensLength,
        ])
      const actualConfig = await blobVerifier.getOffRampConfig()
      expect(actualConfig).to.deep.equal([
        BigNumber.from(newConfig.executionFeeJuels),
        BigNumber.from(newConfig.executionDelaySeconds),
        BigNumber.from(newConfig.maxDataSize),
        BigNumber.from(newConfig.maxTokensLength),
      ])
    })
  })

  describe('#setAFN', () => {
    let newAFN: MockAFN

    beforeEach(async () => {
      newAFN = <MockAFN>(
        await deployContract(roles.defaultAccount, MockAFNArtifact)
      )
    })

    it('only callable by owner', async () => {
      await expect(
        blobVerifier.connect(roles.stranger).setAFN(newAFN.address),
      ).to.be.revertedWith('Only callable by owner')
    })

    it('sets the new AFN', async () => {
      const tx = await blobVerifier
        .connect(roles.defaultAccount)
        .setAFN(newAFN.address)
      expect(await blobVerifier.getAFN()).to.equal(newAFN.address)
      await expect(tx)
        .to.emit(blobVerifier, 'AFNSet')
        .withArgs(afn.address, newAFN.address)
    })
  })

  describe('#setMaxSecondsWithoutAFNHeartbeat', () => {
    let newTime: BigNumber

    beforeEach(async () => {
      newTime = maxTimeBetweenAFNSignals.mul(2)
    })

    it('only callable by owner', async () => {
      await expect(
        blobVerifier
          .connect(roles.stranger)
          .setMaxSecondsWithoutAFNHeartbeat(newTime),
      ).to.be.revertedWith('Only callable by owner')
    })

    it('sets the new max time without afn signal', async () => {
      const tx = await blobVerifier
        .connect(roles.defaultAccount)
        .setMaxSecondsWithoutAFNHeartbeat(newTime)
      expect(await blobVerifier.getMaxSecondsWithoutAFNHeartbeat()).to.equal(
        newTime,
      )
      await expect(tx)
        .to.emit(blobVerifier, 'AFNMaxHeartbeatTimeSet')
        .withArgs(maxTimeBetweenAFNSignals, newTime)
    })
  })

  describe('#typeAndVersion', () => {
    it('should return the correct type and version', async () => {
      const response = await blobVerifier.typeAndVersion()
      await expect(response).to.equal('OffRamp 0.0.1')
    })
  })
})
